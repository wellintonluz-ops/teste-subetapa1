<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Análise de Operação</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- ADICIONADO: Plugin para mostrar labels nos gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Carregando a biblioteca XLSX aqui para garantir que esteja disponível -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        :root {
            /* Original Palette */
            --primary-color: #374151; /* gray-700 */
            --secondary-color: #4B5563; /* gray-600 */
            --accent-color: #3B82F6; /* blue-500 */
            --accent-hover-color: #2563EB; /* blue-600 */
            --danger-color: #EF4444; /* red-500 */
            --danger-hover-color: #DC2626; /* red-600 */
            --background-color: #111827; /* gray-900 */
            --card-bg-color: #1F2937; /* gray-800 */
            --text-color: #D1D5DB; /* gray-300 */
            --text-color-header: #FFFFFF; /* white */

            /* Original Chart Colors (usados como referência para o JS) */
            --chart-grid-color: rgba(107, 114, 128, 0.3); /* gray-500 with opacity */
            --chart-label-color: #D1D5DB; /* gray-300 (mesma cor do text-color) */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            border-color: var(--accent-color);
            color: var(--accent-color);
            background-color: var(--card-bg-color);
            /* text-shadow removed */
        }
        .file-drop-zone {
            transition: all 0.3s ease;
            border-color: var(--secondary-color);
        }
        .file-drop-zone.dragover {
            border-color: var(--accent-color);
            background-color: #2c3a4f; /* Um pouco mais claro no dragover */
             /* box-shadow removed */
        }
        .loader {
            border-top-color: var(--accent-color);
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn-primary {
            background-color: var(--accent-color);
            color: white; /* Cor original */
            font-weight: normal; /* Peso original */
            transition: background-color 0.3s ease; /* Transição original */
            /* box-shadow removed */
            border: none; /* Borda removida */
             padding: 0.5rem 1rem; /* Re-add padding if needed */
             border-radius: 0.375rem; /* Re-add border-radius if needed */
        }
        .btn-primary:hover {
            background-color: var(--accent-hover-color);
            /* box-shadow removed */
        }
        .btn-danger {
            background-color: var(--danger-color);
             color: white; /* Cor original */
            font-weight: normal; /* Peso original */
            transition: background-color 0.3s ease; /* Transição original */
             /* box-shadow removed */
             border: none; /* Borda removida */
             padding: 0.5rem 1rem; /* Re-add padding if needed */
             border-radius: 0.375rem; /* Re-add border-radius if needed */
        }
        .btn-danger:hover {
            background-color: var(--danger-hover-color);
            /* box-shadow removed */
        }
        /* Custom styles for Chart.js dark theme */
        .chart-container {
            position: relative;
            height: 300px;
        }
        /* Style for inputs */
        input[type="date"], input[type="text"], input[type="time"], input[type="number"], select, input[type="month"] {
            background-color: var(--primary-color);
            border-color: var(--secondary-color);
            color: var(--text-color);
            border-width: 1px; /* Garantir que a borda seja visível */
             padding: 0.5rem 0.75rem; /* Add padding for better appearance */
             border-radius: 0.375rem; /* Add border-radius */
        }
        input[type="date"]:focus, input[type="text"]:focus, input[type="time"]:focus, input[type="number"]:focus, select:focus, input[type="month"]:focus {
             border-color: var(--accent-color); /* Destaca a borda ao focar */
             box-shadow: 0 0 0 1px var(--accent-color); /* Add focus ring matching accent */
             outline: none; /* Remove o outline padrão */
        }

        input[type="date"]::-webkit-calendar-picker-indicator,
        input[type="month"]::-webkit-calendar-picker-indicator {
            filter: invert(1); /* Filtro original */
        }
        .mov-sub-tab.active {
            color: var(--accent-color);
            border-color: var(--accent-color);
            /* text-shadow removed */
        }
        /* Modal styles */
        .modal-backdrop {
            background-color: rgba(0,0,0,0.6); /* Cor original */
        }
        /* Feedback message styles - manter como estava */
        #feedback-message-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .feedback-message {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            max-width: 90%;
            text-align: center;
            transform: translateY(20px);
        }
        .feedback-message.show {
            opacity: 1;
            transform: translateY(0);
        }
        .feedback-message.success { background-color: #10B981; } /* green-500 */
        .feedback-message.error { background-color: #EF4444; } /* red-500 */
        .feedback-message.warning { background-color: #F59E0B; } /* amber-500 */
        .feedback-message.info { background-color: #3B82F6; } /* blue-500 */

    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>

<body class="p-4 md:p-8">

    <!-- Container principal com fundo original -->
    <div class="max-w-7xl mx-auto bg-gray-900 rounded-2xl shadow-lg p-6 md:p-8 border border-gray-700">
        <header class="mb-6 border-b border-gray-700 pb-4">
            <h1 class="text-3xl font-bold text-gray-100">Sistema de Análise de Operação</h1>
            <p class="text-gray-400 mt-1">Importe suas bases de dados para gerar insights.</p>
        </header>

        <!-- Abas de Navegação -->
         <div class="border-b border-gray-700 mb-6">
            <nav class="-mb-px flex flex-wrap space-x-6" aria-label="Tabs">
                <button id="tab-btn-importacao" class="tab-button active whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">
                    Importação
                </button>
                 <button id="tab-btn-dashboard" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Dashboard
                </button>
                <button id="tab-btn-operacao" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Indicadores de Operação
                </button>
                 <button id="tab-btn-absenteismo" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Absenteísmo
                </button>
                 <button id="tab-btn-movimentacoes" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Histórico mensal de operação empilhadeira
                </button>
                 <button id="tab-btn-regras" class="tab-button whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300 hover:border-gray-500">
                    Regras
                </button>
            </nav>
        </div>


        <!-- Conteúdo das Abas -->
        <main>
            <!-- Aba de Importação -->
            <div id="tab-content-importacao">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">

                    <!-- Card de Importação de Expedição -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Arquivo Expedição</h2>
                        <p class="text-sm text-gray-400 mb-4">Selecione ou arraste um arquivo .csv ou .xlsx.</p>
                        <div id="expedicao-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="expedicao-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                            <p id="expedicao-file-label" class="text-gray-400">Arraste e solte ou clique aqui.</p>
                        </div>
                         <div id="expedicao-file-info" class="mt-4 text-center hidden">
                            <p class="text-sm text-gray-300 font-medium"></p>
                            <button id="expedicao-remove-file-btn" class="mt-2 text-xs text-red-400 hover:text-red-500">Remover Arquivo</button>
                        </div>
                        <div id="expedicao-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                    </div>

                     <!-- Card de Importação de Absenteísmo -->
                     <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Arquivo Absenteísmo</h2>
                        <p class="text-sm text-gray-400 mb-4">Importe o relatório diário.</p>
                        <div id="absenteismo-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="absenteismo-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                            <p id="absenteismo-file-label" class="text-gray-400">Arraste e solte ou clique aqui.</p>
                        </div>
                        <div id="absenteismo-file-info" class="mt-4 text-center hidden">
                            <p class="text-sm text-gray-300 font-medium"></p>
                            <button id="absenteismo-remove-file-btn" class="mt-2 text-xs text-red-400 hover:text-red-500">Remover Arquivo</button>
                        </div>
                         <div id="absenteismo-preview-container" class="hidden mt-4">
                            <p class="text-sm font-medium text-center text-gray-300">Dados importados para o dia <span id="absenteismo-date-preview" class="font-bold text-blue-400"></span>.
                            </p>
                            <div class="flex justify-center mt-4">
                               <button id="save-absenteismo-btn" class="btn-primary py-2 px-4 rounded-lg"> <!-- Removed font-bold -->
                                 Salvar Histórico
                                </button>
                            </div>
                        </div>
                        <div id="absenteismo-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                         <div id="absenteismo-feedback" class="mt-4 text-center"></div>
                    </div>

                    <!-- Card de Importação de Empilhadeira -->
                     <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-2">Importar Mov. Empilhadeira</h2>
                        <p class="text-sm text-gray-400 mb-4">Selecione ou arraste o arquivo.</p>
                        <div id="empilhadeira-drop-zone" class="file-drop-zone border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-blue-500 hover:bg-gray-700/50">
                            <input type="file" id="empilhadeira-file-input" class="hidden" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel">
                            <p id="empilhadeira-file-label" class="text-gray-400">Arraste e solte ou clique aqui.</p>
                        </div>
                         <div id="empilhadeira-file-info" class="mt-4 text-center hidden">
                            <p class="text-sm text-gray-300 font-medium"></p>
                            <button id="empilhadeira-remove-file-btn" class="mt-2 text-xs text-red-400 hover:text-red-500">Remover Arquivo</button>
                        </div>
                        <div id="empilhadeira-loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto mt-4 hidden"></div>
                    </div>

                </div>
            </div>

            <!-- Aba de Dashboard -->
            <div id="tab-content-dashboard" class="hidden">
                 <div class="bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md">
                    <div class="flex flex-wrap items-center gap-4 mb-4">
                        <div>
                            <label for="dashboard-date-filter" class="block text-sm font-medium text-gray-300">Selecione a Data:</label>
                            <input type="date" id="dashboard-date-filter" class="mt-1 block rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <button id="dashboard-fetch-btn" class="btn-primary py-2 px-4 rounded-lg self-end">Buscar Dados</button> <!-- Removed font-bold -->
                    </div>
                    <div id="dashboard-feedback" class="text-center mb-4"></div>
                </div>

                <div id="dashboard-results-container" class="mt-6">
                    <!-- Dashboard content will be rendered here -->
                </div>
                 <div id="dashboard-placeholder" class="text-center py-12 text-gray-500">
                     <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                         <path stroke-linecap="round" stroke-linejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18M12 12.75h.008v.008H12v-.008Z" />
                     </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Selecione uma data</h3>
                    <p class="mt-1 text-sm text-gray-400">Escolha uma data e clique em "Buscar Dados" para ver a performance.</p>
                </div>
            </div>

            <!-- Aba de Indicadores de Operação -->
            <div id="tab-content-operacao" class="hidden">
                <!-- FILTRO DE TURNO ATUALIZADO -->
                <div class="mb-6 bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md">
                    <label for="mov-turno-filter" class="block text-sm font-medium text-gray-300">Comparar 1° Turno com:</label>
                    <select id="mov-turno-filter" class="mt-1 block w-full md:w-1/4 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                        <option value="2° TURNO" selected>2° Turno</option>
                        <option value="todos">Todos os Turnos (Total)</option>
                    </select>
                </div>
                <!-- FIM FILTRO -->

                 <div id="operacao-placeholder" class="text-center py-12 text-gray-500">
                     <svg class="mx-auto h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                         <path stroke-linecap="round" stroke-linejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0 0 20.25 18V5.25A2.25 2.25 0 0 0 18 3H6A2.25 2.25 0 0 0 3.75 5.25v12.75A2.25 2.25 0 0 0 6 20.25Z" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Carregue os arquivos de Expedição e Mov. Empilhadeira</h3>
                    <p class="mt-1 text-sm text-gray-400">Os gráficos de indicadores aparecerão aqui.</p>
                </div>
                <!-- Container modificado para space-y -->
                <div id="operacao-charts-container" class="hidden space-y-8">
                    <!-- Charts will be rendered here -->
                </div>
            </div>


            <!-- Aba de Absenteísmo -->
            <div id="tab-content-absenteismo" class="hidden">
                <div class="mb-4">
                    <label for="absenteismo-date-filter" class="block text-sm font-medium text-gray-300">Filtrar por Data:</label>
                    <input type="date" id="absenteismo-date-filter" name="absenteismo-date-filter" class="mt-1 block w-full md:w-1/4 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                </div>
                <div id="absenteismo-table-container">
                    <!-- Tabela de histórico será inserida aqui -->
                </div>
                <div id="absenteismo-placeholder" class="text-center py-12 text-gray-500">
                    <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                         <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Histórico de Absenteísmo</h3>
                    <p class="mt-1 text-sm text-gray-400">Selecione uma data ou salve novos dados.</p>
                </div>
            </div>

            <!-- Aba de Movimentações de Empilhadeira -->
            <div id="tab-content-movimentacoes" class="hidden">
                 <div id="movimentacoes-dashboard-content">
                    <!-- Conteúdo será preenchido via JS -->
                 </div>
                 <div id="movimentacoes-placeholder" class="text-center py-12 text-gray-500">
                    <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                       <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-200">Nenhum dado para exibir</h3>
                    <p class="mt-1 text-sm text-gray-400">Importe o arquivo de movimentações para começar.</p>
                 </div>
            </div>

             <!-- Aba de Regras -->
            <div id="tab-content-regras" class="hidden">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <!-- Formulário para Downtime -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Cadastrar Regra de Downtime</h2>
                        <form id="form-regra-downtime">
                            <div class="mb-4">
                                <label for="motivo-downtime" class="block text-sm font-medium text-gray-300">Motivo</label>
                                <input type="text" id="motivo-downtime" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                            </div>
                            <div class="mb-4">
                                <label for="tempo-downtime" class="block text-sm font-medium text-gray-300">Tempo (HH:MM)</label>
                                <input type="time" id="tempo-downtime" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                            </div>
                            <button type="submit" class="btn-primary py-2 px-4 rounded-lg w-full">Salvar Regra</button> <!-- Removed font-bold -->
                        </form>
                        <div id="downtime-feedback" class="mt-4 text-center"></div>
                    </div>
                     <!-- Formulário para Meta -->
                    <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                         <h2 class="text-xl font-semibold text-gray-200 mb-4">Cadastrar Meta por Atividade</h2>
                        <form id="form-meta">
                            <div class="mb-4">
                                <label for="meta-atividade-nome" class="block text-sm font-medium text-gray-300">Nome da Atividade</label>
                                <input type="text" id="meta-atividade-nome" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required>
                            </div>
                            <div class="flex gap-4 mb-4">
                                <div class="flex-1">
                                    <label for="meta-atividade-valor" class="block text-sm font-medium text-gray-300">Valor da Meta</label>
                                    <input type="number" id="meta-atividade-valor" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required min="0" step="any">
                                </div>
                                <div class="flex-1">
                                    <label for="meta-atividade-unidade" class="block text-sm font-medium text-gray-300">Unidade</label>
                                    <select id="meta-atividade-unidade" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                                        <option value="/ Hr">/ Hr</option>
                                        <option value="/ Min">/ Min</option>
                                    </select>
                                </div>
                            </div>
                             <button type="submit" class="btn-primary py-2 px-4 rounded-lg w-full">Salvar Meta</button> <!-- Removed font-bold -->
                        </form>
                        <div id="meta-feedback" class="mt-4 text-center"></div>
                    </div>
                </div>
                 <!-- Lista de regras salvas -->
                <div class="mt-8 bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                     <h2 class="text-xl font-semibold text-gray-200 mb-4">Regras de Downtime Salvas</h2>
                     <div id="regras-downtime-list-container">
                         <!-- A lista de regras será inserida aqui -->
                     </div>
                </div>
                <!-- Lista de metas salvas -->
                <div class="mt-8 bg-gray-800 p-6 rounded-lg border border-gray-700 shadow-md">
                     <h2 class="text-xl font-semibold text-gray-200 mb-4">Metas por Atividade Salvas</h2>
                     <div id="regras-meta-list-container">
                         <!-- A lista de metas será inserida aqui -->
                     </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Modal para Lançar Downtime -->
    <div id="downtime-modal" class="fixed inset-0 z-50 flex items-center justify-center hidden modal-backdrop">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md border border-gray-700"> <!-- Background original -->
             <h2 class="text-xl font-semibold text-gray-200 mb-4">Lançar Downtime para <span id="modal-operator-name" class="font-bold text-blue-400"></span></h2> <!-- Cor original -->
             <form id="form-lancar-downtime">
                 <input type="hidden" id="modal-operator-id">
                 <div class="mb-4">
                     <label for="modal-downtime-reason" class="block text-sm font-medium text-gray-300">Motivo</label>
                     <select id="modal-downtime-reason" class="mt-1 block w-full rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" required></select>
                 </div>
                 <div id="modal-downtime-list" class="mb-4 space-y-2 max-h-40 overflow-y-auto p-2 bg-gray-700 rounded"> <!-- Cor original -->
                    <!-- Lançamentos de downtime serão listados aqui -->
                 </div>
                 <div class="flex justify-end gap-4 mt-6">
                    <button type="button" id="modal-close-btn" class="px-4 py-2 rounded-lg text-gray-300 hover:bg-gray-600">Fechar</button> <!-- Cor original -->
                    <button type="submit" class="btn-primary py-2 px-4 rounded-lg">Adicionar Downtime</button> <!-- Removed font-bold -->
                 </div>
             </form>
        </div>
    </div>

    <!-- Feedback Message Container -->
    <div id="feedback-message-container"></div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, enableIndexedDbPersistence, collection, doc, writeBatch, query, getDocs, where, addDoc, onSnapshot, deleteDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        document.addEventListener('DOMContentLoaded', () => {

            // --- Firebase Initialization ---
             // Use environment variables for Firebase config
            const firebaseConfig = typeof __firebase_config !== 'undefined'
                ? JSON.parse(__firebase_config)
                : { // Fallback config (consider removing or securing)
                    apiKey: "YOUR_FALLBACK_API_KEY", // Replace if necessary
                    authDomain: "YOUR_FALLBACK_AUTH_DOMAIN",
                    projectId: "YOUR_FALLBACK_PROJECT_ID",
                    storageBucket: "YOUR_FALLBACK_STORAGE_BUCKET",
                    messagingSenderId: "YOUR_FALLBACK_SENDER_ID",
                    appId: "YOUR_FALLBACK_APP_ID",
                    measurementId: "YOUR_FALLBACK_MEASUREMENT_ID"
                };

            // Use environment variable for App ID
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Use provided appId or a default

            // --- App State ---
            let app, db, auth;
            let isFirebaseInitialized = false;
            let userId = null; // To store the authenticated user ID
            let expedicaoData = [];
            let movimentacoesData = [];
            let absenteismoData = []; // Store parsed absenteismo data temporarily
            let absenteismoFileDate = null;
            let unsubDowntime, unsubMetas;
            let metasPorAtividade = {};
            let downtimeRules = []; // AGORA VAI GUARDAR AS REGRAS (DA ABA REGRAS)
            let operatorPerformanceData = {};
            let charts = {}; // To hold chart instances

            // --- Global Element Variables ---
            let tabs, expedicaoElements, absenteismoElements, regrasElements, movimentacoesElements, dashboardElements, operacaoElements;

             // --- Feedback Message Function ---
            function showFeedback(message, type = 'info', duration = 3000) {
                const container = document.getElementById('feedback-message-container');
                if (!container) {
                    console.error("Feedback container not found!");
                    return;
                }

                const feedbackDiv = document.createElement('div');
                feedbackDiv.className = `feedback-message ${type}`;
                feedbackDiv.textContent = message;
                container.appendChild(feedbackDiv);

                // Trigger reflow to enable transition for showing
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                         feedbackDiv.classList.add('show');
                    });
                });


                // Set timeout to remove the message
                setTimeout(() => {
                    feedbackDiv.classList.remove('show');
                    // Remove the element from the DOM after the transition ends
                    feedbackDiv.addEventListener('transitionend', () => {
                         // Double check parentNode before removal
                        if (feedbackDiv.parentNode === container) {
                            container.removeChild(feedbackDiv);
                        }
                    }, { once: true });
                 }, duration);
            }


            // --- ALL FUNCTIONS ARE DEFINED BELOW ---
            
            // *** CORREÇÃO: Definindo as cores padrão do Chart.js UMA VEZ ***
            Chart.defaults.color = '#D1D5DB'; // Cor do texto (eixos, legendas)
            Chart.defaults.borderColor = 'rgba(107, 114, 128, 0.3)'; // Cor das grades
            
            // *** ADICIONADO: Registrar o plugin datalabels ***
            if (window.ChartDataLabels) {
                Chart.register(ChartDataLabels);
                Chart.defaults.plugins.datalabels.display = false; // Desligar por padrão
            } else {
                console.warn("Chart.js Datalabels plugin not loaded.");
            }


            async function initializeFirebase() {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    // *** CORREÇÃO IndexedDB: Tentar ativar a persistência, mas não falhar se der erro ***
                    try {
                        await enableIndexedDbPersistence(db);
                        console.log("Firebase persistence enabled.");
                    } catch (error) {
                        if (error.code == 'failed-precondition') {
                            console.warn("Firebase persistence failed (multiple tabs open?):", error.message);
                            // Esta é uma falha esperada se o usuário tiver vários tabs abertos
                        } else {
                            console.error("Firebase persistence failed to enable (IndexedDB issue):", error.message);
                            showFeedback("Persistência local (offline) falhou.", "warning");
                        }
                    }
                    // *** FIM DA CORREÇÃO ***

                     // Use provided token or sign in anonymously
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) { // Check if token is non-empty
                        await signInWithCustomToken(auth, __initial_auth_token);
                        console.log("Firebase initialized and user signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Firebase initialized and user signed in anonymously.");
                    }

                    // Wait for auth state to be confirmed before getting user ID
                    await new Promise(resolve => {
                        const unsubscribe = auth.onAuthStateChanged(user => {
                            if (user) {
                                userId = user.uid;
                            } else {
                                // Handle anonymous user ID generation if needed, or rely on rules
                                userId = `anon_${crypto.randomUUID()}`; // Example for anonymous
                            }
                            unsubscribe();
                            resolve();
                        });
                    });

                    isFirebaseInitialized = true;
                    console.log("Using User ID:", userId); // Log the user ID
                    console.log("Using App ID:", appId);   // Log the app ID


                    // Load data associated with the user/app
                    loadAbsenteismoHistory(); // Load initial history for today
                    listenForDowntimeUpdates();
                    listenForMetasUpdates();

                } catch (error) {
                    console.error("Critical Firebase Initialization Error:", error);
                     showFeedback("Erro crítico ao inicializar o banco de dados. Funcionalidades de salvar/carregar podem não funcionar.", "error", 5000);
                }
            }

            // --- Firestore Path Helper ---
            // Helper to get correct Firestore paths
            function getFirestorePath(collectionName, isPublic = false) {
                 if (!userId || !appId) { // Ensure both userId and appId are available
                    console.error("User ID or App ID not available for Firestore path.");
                    showFeedback("Erro: ID do usuário ou aplicativo indisponível.", "error");
                    return null; // Or handle appropriately
                }
                if (isPublic) {
                    // Public data path
                    return `artifacts/${appId}/public/data/${collectionName}`;
                } else {
                    // Private user data path (default)
                    return `artifacts/${appId}/users/${userId}/${collectionName}`;
                }
            }


            function switchTab(targetTab) {
                Object.values(tabs).forEach(tab => {
                    if (tab.btn && tab.content) { // Check if elements exist
                        tab.btn.classList.remove('active');
                        tab.content.classList.add('hidden');
                    }
                });
                if (tabs[targetTab] && tabs[targetTab].btn && tabs[targetTab].content) { // Check target exists
                    tabs[targetTab].btn.classList.add('active');
                    tabs[targetTab].content.classList.remove('hidden');

                    // If switching to 'Indicadores de Operação', attempt to calculate/render charts
                    if(targetTab === 'operacao' && operacaoElements && operacaoElements.chartsContainer) { // Check if elements are ready
                         if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                            calcularIndicadoresOperacao();
                         } else {
                             // Ensure placeholder is shown if data isn't ready
                             operacaoElements.chartsContainer.classList.add('hidden');
                             operacaoElements.placeholder.classList.remove('hidden');
                         }
                    }
                } else {
                    console.error(`Tab or elements for "${targetTab}" not found.`);
                }
            }


            function setupFileInput(elements, fileHandler) {
                // Ensure elements exist before adding listeners
                if (!elements || !elements.dropZone || !elements.fileInput || !elements.removeBtn) {
                    console.error("Missing elements for file input setup:", elements);
                    return;
                }
                elements.dropZone.addEventListener('click', () => elements.fileInput.click());
                elements.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.add('dragover');
                });
                elements.dropZone.addEventListener('dragleave', () => elements.dropZone.classList.remove('dragover'));
                elements.dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    elements.dropZone.classList.remove('dragover');
                    if (e.dataTransfer.files.length) {
                        elements.fileInput.files = e.dataTransfer.files;
                        fileHandler(e.dataTransfer.files[0]);
                    }
                });
                elements.fileInput.addEventListener('change', (e) => {
                     if (e.target.files.length) {
                        fileHandler(e.target.files[0]);
                    }
                });
                elements.removeBtn.addEventListener('click', () => {
                    elements.fileInput.value = ''; // Clear the file input
                    // Reset UI elements safely, checking they exist first
                    if (elements.fileInfo) elements.fileInfo.classList.add('hidden');
                    if (elements.dropZone) elements.dropZone.classList.remove('hidden');
                    if (elements.fileLabel) elements.fileLabel.classList.remove('hidden');

                    if (elements.previewContainer) elements.previewContainer.classList.add('hidden');
                    if (elements.feedback) elements.feedback.innerHTML = '';


                    // Clear relevant data and update dependent UI sections
                    if (elements === expedicaoElements) {
                        expedicaoData = [];
                        if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                            operacaoElements.chartsContainer.classList.add('hidden');
                            operacaoElements.placeholder.classList.remove('hidden');
                        }
                    } else if (elements === absenteismoElements) {
                        absenteismoData = []; // Clear parsed data too
                        absenteismoFileDate = null;
                        if(elements.previewContainer) elements.previewContainer.classList.add('hidden'); // Ensure preview is hidden
                    } else if (elements === movimentacoesElements) {
                        movimentacoesData = [];
                        if (movimentacoesElements && movimentacoesElements.dashboardContent && movimentacoesElements.placeholder) {
                            movimentacoesElements.dashboardContent.innerHTML = '';
                            movimentacoesElements.placeholder.classList.remove('hidden');
                        }
                        if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                            operacaoElements.chartsContainer.classList.add('hidden');
                            operacaoElements.placeholder.classList.remove('hidden');
                        }
                         // Clear dashboard if dependent on this file
                         if (dashboardElements && dashboardElements.resultsContainer && dashboardElements.placeholder) {
                            dashboardElements.resultsContainer.innerHTML = '';
                            dashboardElements.placeholder.classList.remove('hidden');
                            operatorPerformanceData = {}; // Clear performance data as well
                         }
                    }
                });
            }

            function showFileInfo(elements, file) {
                // Check if elements exist before manipulating them
                if (!elements || !elements.fileInfoP || !elements.dropZone || !elements.fileInfo || !elements.fileLabel) {
                    console.error("Missing elements for showFileInfo:", elements);
                    return;
                }
                elements.fileInfoP.textContent = `Arquivo selecionado: ${file.name}`;
                elements.dropZone.classList.add('hidden');
                elements.fileInfo.classList.remove('hidden');
                elements.fileLabel.classList.add('hidden');
            }

            // --- Indicadores de Operação Functions ---
            async function calcularIndicadoresOperacao() {
                 // Ensure elements are available
                 if (!operacaoElements || !operacaoElements.chartsContainer || !operacaoElements.placeholder) {
                     console.error("Operacao elements not ready for calculating indicators.");
                     return;
                 }
                // *** ADICIONADO: Ler o filtro de turno ***
                const selectedTurno = operacaoElements.turnoFilter.value;

                 if (expedicaoData.length === 0 || movimentacoesData.length === 0) {
                     operacaoElements.chartsContainer.classList.add('hidden');
                     operacaoElements.placeholder.classList.remove('hidden');
                    return;
                }

                operacaoElements.placeholder.classList.add('hidden');
                operacaoElements.chartsContainer.classList.remove('hidden');
                operacaoElements.chartsContainer.innerHTML = '<div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto"></div>';

                 // --- Fetching data needs correct paths ---
                const absenteismoPath = getFirestorePath('absenteismo');
                // const downtimesPath = getFirestorePath('downtimes_lancados'); // NÃO MAIS USADO AQUI
                
                // *** MUDANÇA: AGORA USA AS REGRAS DE DOWNTIME (junto com dados de absenteísmo) ***
                // downtimeRules (REGRAS) já está em memória (via listener)
                
                if (!absenteismoPath) {
                     showFeedback("Erro: Não foi possível obter os caminhos do banco de dados.", "error");
                     operacaoElements.chartsContainer.innerHTML = '<p class="text-red-400 text-center">Erro ao acessar o banco de dados.</p>';
                    return;
                }

                // Fetch data using the correct paths
                // REMOVIDO: fetch de allDowntimes (lançados)
                const allAbsenteismo = await getFirestoreCollection(absenteismoPath);
                
                // --- AGGREGATION ---
                const monthlyAgg = {};
                
                // *** NOVO: Mapa para lookup de setor por operador/data ***
                const operatorSectorMap = new Map(); // Chave: "YYYY-MM-DD_OperadorNome" -> "PICKING" | "EXPEDIÇÃO" | "OPERADOR DE EMPILHADEIRA 1° TURNO" | "OUTRO"

                const processExpedicaoForIndicators = (data) => {
                     data.forEach(item => {
                        // REVERTIDO: Usar dataEnvio (K) para agregação mensal E média diária
                        const date = item.dataEnvio; // Vindo da Coluna K
                        
                        if (date instanceof Date && !isNaN(date)) {
                            // Chave para total mensal (Gráfico expMensal)
                            const monthKey = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}`;
                            
                            if (!monthlyAgg[monthKey]) initMonthAgg(monthKey);
                            
                            // Somar Quantidade (Q) para o total mensal
                            monthlyAgg[monthKey].expedicaoTotal += item.quantidade; 
                            
                            // Adicionar dia para cálculo da média diária (Gráfico mediaExpDia)
                            monthlyAgg[monthKey].expedicaoDias.add(date.getUTCDate());
                        }
                    });
                };


                const processMovimentacoesForIndicators = (data) => {
                     data.forEach(item => {
                        const year = item.ano;
                        const month = item.mes;
                        const turno = item.turno; // Already processed

                        // *** VALIDATION for monthly count ***
                        if (typeof year !== 'number' || isNaN(year) || typeof month !== 'number' || isNaN(month) || month < 1 || month > 12 || !turno) {
                            // console.warn("Skipping indicator aggregation due to invalid year/month/turno:", item); // Optional: See skipped items
                            return; // Skip if essential fields for monthly count are invalid
                        }
                        // *** END VALIDATION ***

                        const monthKey = `${year}-${String(month).padStart(2, '0')}`;

                        if (!monthlyAgg[monthKey]) initMonthAgg(monthKey);

                        // *** LÓGICA DO FILTRO ATUALIZADA ***
                        // AGORA AGREGA T1 E T2 SEPARADAMENTE
                        const isTurno1 = (turno === '1° TURNO');
                        const isTurno2 = (turno === '2° TURNO');

                        // Agrega para Todos (T1 + T2)
                        if (isTurno1 || isTurno2) {
                            monthlyAgg[monthKey].movimentacoesTotal_Todos++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_Todos.add(item.data.getUTCDate());
                            }
                        }
                        
                        // Agrega por turno específico
                        if (isTurno1) {
                            monthlyAgg[monthKey].movimentacoesTotal_T1++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_T1.add(item.data.getUTCDate());
                            }
                        } else if (isTurno2) {
                            monthlyAgg[monthKey].movimentacoesTotal_T2++;
                            if (item.data instanceof Date && !isNaN(item.data)) {
                                monthlyAgg[monthKey].movimentacaoDias_T2.add(item.data.getUTCDate());
                            }
                        }
                    });
                };

                 const initMonthAgg = (key) => {
                     monthlyAgg[key] = {
                        expedicaoTotal: 0,
                        expedicaoDias: new Set(),
                        // ADICIONADOS
                        movimentacoesTotal_T1: 0,
                        movimentacaoDias_T1: new Set(),
                        movimentacoesTotal_T2: 0,
                        movimentacaoDias_T2: new Set(),
                        movimentacoesTotal_Todos: 0,
                        movimentacaoDias_Todos: new Set(),
                        
                        // *** MUDANÇA AQUI ***
                        horasPrevistasPickingMin: 0, 
                        horasPrevistasExpedicaoMin: 0,
                        horasPrevistasOpEmpMin: 0,
                        
                        // *** NOVOS: Horas Normais e Downtime ***
                        horasNormaisPickingMin: 0,
                        horasNormaisExpedicaoMin: 0,
                        horasNormaisOpEmpMin: 0,
                        
                        // *** NOVOS: Contagem de dias úteis por setor (baseado em absenteísmo) ***
                        diasUteisPicking: new Set(),
                        diasUteisExpedicao: new Set(),
                        diasUteisOpEmp: new Set(),
                    };
                };

                processExpedicaoForIndicators(expedicaoData);
                processMovimentacoesForIndicators(movimentacoesData);

                 // Aggregate absenteism data (SOMA DE HORAS PREVISTAS)
                allAbsenteismo.forEach(item => {
                    if (!item.data || !item.colaborador) return; // Ensure 'data' and 'colaborador' fields exist (YYYY-MM-DD)
                    const [year, month, day] = item.data.split('-');
                    const monthKey = `${year}-${month}`;
                    
                    // Tenta encontrar o mês na agregação. Se não existir, cria um novo.
                    if (!monthlyAgg[monthKey]) {
                        // Verifica se a chave é válida (ex: 2025-10)
                        const [y, m] = monthKey.split('-');
                        if (!isNaN(parseInt(y)) && !isNaN(parseInt(m)) && m >= 1 && m <= 12) {
                             initMonthAgg(monthKey);
                        } else {
                            // console.warn("Skipping absenteism aggregation for invalid monthKey:", monthKey);
                            return; // Pula se a chave (data) for inválida
                        }
                    }

                    const locais = String(item.locaisDeTrabalho || '').toUpperCase();
                    const minutosPrevistos = timeStringToMinutes(item.horasPrevistas); // MUDANÇA AQUI
                    const minutosNormais = timeStringToMinutes(item.horasNormaisTrabalhadas); // NOVO
                    
                    const mapKey = `${item.data}_${item.colaborador}`; // Chave para o lookup

                    // *** LÓGICA ATUALIZADA PARA 3 BARRAS ***
                    if (locais.includes('PICKING')) {
                        monthlyAgg[monthKey].horasPrevistasPickingMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisPickingMin += minutosNormais; // NOVO
                        monthlyAgg[monthKey].diasUteisPicking.add(day); // NOVO: Conta dia útil
                        operatorSectorMap.set(mapKey, "PICKING"); // NOVO: Mapeia setor
                    }
                    if (locais.includes('EXPEDIÇÃO')) { 
                        monthlyAgg[monthKey].horasPrevistasExpedicaoMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisExpedicaoMin += minutosNormais; // NOVO
                        monthlyAgg[monthKey].diasUteisExpedicao.add(day); // NOVO: Conta dia útil
                        operatorSectorMap.set(mapKey, "EXPEDIÇÃO"); // NOVO: Mapeia setor
                    }
                    if (locais.includes('OPERADOR DE EMPILHADEIRA 1° TURNO')) { 
                        monthlyAgg[monthKey].horasPrevistasOpEmpMin += minutosPrevistos;
                        monthlyAgg[monthKey].horasNormaisOpEmpMin += minutosNormais; // NOVO
                        monthlyAgg[monthKey].diasUteisOpEmp.add(day); // NOVO: Conta dia útil
                        operatorSectorMap.set(mapKey, "OPERADOR DE EMPILHADEIRA 1° TURNO"); // NOVO: Mapeia setor
                    }
                });


                // --- INÍCIO: Nova Lógica de Cálculo de Downtime (Req 1 e 2) ---
                
                // --- Agregação para Gráfico de Downtime (Req 2) ---
                const downtimePorMotivoMin = {};
                
                // --- Agregação para Desconto (Req 1) ---
                // (Total de minutos de downtime por setor, baseado nas REGRAS)
                const downtimeTotalMinPorSetor = {
                    PICKING: 0,
                    EXPEDIÇÃO: 0,
                    OP_EMP: 0,
                    GERAL: 0 // Para regras que se aplicam a todos
                };
                
                // 1. Processar REGRAS de downtime
                downtimeRules.forEach(rule => {
                    const motivo = rule.motivo;
                    const tempoMin = timeStringToMinutes(rule.tempo);
                    const motivoUpper = motivo.toUpperCase();

                    // Req 2: Acumular total por motivo
                    if (!downtimePorMotivoMin[motivo]) {
                        downtimePorMotivoMin[motivo] = 0;
                    }
                    downtimePorMotivoMin[motivo] += tempoMin;

                    // Req 1: Acumular total por setor
                    // (Esta lógica assume que o nome do motivo indica o setor)
                    if (motivoUpper.includes('PICKING')) {
                        downtimeTotalMinPorSetor.PICKING += tempoMin;
                    } else if (motivoUpper.includes('EXPEDIÇÃO') || motivoUpper.includes('EXPEDICAO')) {
                        downtimeTotalMinPorSetor.EXPEDIÇÃO += tempoMin;
                    } else if (motivoUpper.includes('EMPILHADEIRA') || motivoUpper.includes('OP EMP')) {
                        downtimeTotalMinPorSetor.OP_EMP += tempoMin;
                    } else {
                        // Se não for específico, é GERAL (ex: Café, Banheiro)
                        downtimeTotalMinPorSetor.GERAL += tempoMin;
                    }
                });

                // 2. Calcular "Taxa Diária" de Downtime (Req 1)
                
                // Calcular o total de dias úteis trabalhados EM TODOS OS MESES para cada setor
                let totalDiasUteisPicking = 0;
                let totalDiasUteisExpedicao = 0;
                let totalDiasUteisOpEmp = 0;

                Object.values(monthlyAgg).forEach(agg => {
                    totalDiasUteisPicking += agg.diasUteisPicking.size;
                    totalDiasUteisExpedicao += agg.diasUteisExpedicao.size;
                    totalDiasUteisOpEmp += agg.diasUteisOpEmp.size;
                });
                
                // (Evitar divisão por zero)
                // *** MUDANÇA: Usar 21 dias fixos para calcular a taxa diária ***
                const DIAS_UTEIS_FIXOS_PARA_TAXA = 21;

                const taxaDiariaPicking = (downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;
                const taxaDiariaExpedicao = (downtimeTotalMinPorSetor.EXPEDIÇÃO + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;
                const taxaDiariaOpEmp = (downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;


                // 3. Aplicar desconto de downtime às Horas Normais (Req 1)
                Object.keys(monthlyAgg).forEach(monthKey => {
                    const agg = monthlyAgg[monthKey];
                    
                    // Calcular o downtime a ser descontado *naquele mês*
                    const descontoDowntimePicking = taxaDiariaPicking * agg.diasUteisPicking.size;
                    const descontoDowntimeExpedicao = taxaDiariaExpedicao * agg.diasUteisExpedicao.size;
                    const descontoDowntimeOpEmp = taxaDiariaOpEmp * agg.diasUteisOpEmp.size;

                    // Aplicar o desconto (Math.max para não negativar)
                    agg.horasNormaisPickingMin = Math.max(0, agg.horasNormaisPickingMin - descontoDowntimePicking);
                    agg.horasNormaisExpedicaoMin = Math.max(0, agg.horasNormaisExpedicaoMin - descontoDowntimeExpedicao);
                    agg.horasNormaisOpEmpMin = Math.max(0, agg.horasNormaisOpEmpMin - descontoDowntimeOpEmp);
                });
                
                // --- FIM: Nova Lógica de Cálculo de Downtime ---
                

                const sortedMonths = Object.keys(monthlyAgg).sort();

                // ... rest of chart data preparation and rendering remains the same ...
                const labels = sortedMonths.map(key => {
                     const [year, month] = key.split('-');
                      // Format label as 'Mês/Ano' using UTC date
                     return new Date(Date.UTC(year, month - 1)).toLocaleString('pt-BR', { month: 'short', year: '2-digit', timeZone: 'UTC' });
                });

                // --- Prepare Chart Data ---
                 const expData = sortedMonths.map(k => (monthlyAgg[k].expedicaoTotal || 0));
                
                // *** NOVOS ARRAYS DE DADOS DE MOVIMENTAÇÃO ***
                const movData_T1 = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_T1 || 0));
                const movData_T2 = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_T2 || 0));
                const movData_Todos = sortedMonths.map(k => (monthlyAgg[k].movimentacoesTotal_Todos || 0));
                
                 // Average items shipped per day the shipping department worked
                const mediaExpDiaData = sortedMonths.map(k => monthlyAgg[k].expedicaoDias.size > 0 ? (monthlyAgg[k].expedicaoTotal || 0) / monthlyAgg[k].expedicaoDias.size : 0);
                
                // *** NOVOS ARRAYS DE MÉDIA DIÁRIA DE MOVIMENTAÇÃO ***
                const mediaMovDiaData_T1 = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_T1.size > 0 ? (monthlyAgg[k].movimentacoesTotal_T1 || 0) / monthlyAgg[k].movimentacaoDias_T1.size : 0);
                const mediaMovDiaData_T2 = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_T2.size > 0 ? (monthlyAgg[k].movimentacoesTotal_T2 || 0) / monthlyAgg[k].movimentacaoDias_T2.size : 0);
                const mediaMovDiaData_Todos = sortedMonths.map(k => monthlyAgg[k].movimentacaoDias_Todos.size > 0 ? (monthlyAgg[k].movimentacoesTotal_Todos || 0) / monthlyAgg[k].movimentacaoDias_Todos.size : 0);


                const crescimentoExpData = sortedMonths.map((k, i) => {
                    if (i === 0) return 0; // No growth for the first month
                    const prevKey = sortedMonths[i-1];
                    const atual = monthlyAgg[k].expedicaoTotal;
                    const anterior = monthlyAgg[prevKey]?.expedicaoTotal; // Use optional chaining
                    // Handle cases where previous month might be zero or missing
                    if (anterior === undefined || anterior === null) return (atual > 0 ? Infinity : 0); // Or handle as needed
                    return anterior > 0 ? ((atual / anterior) - 1) * 100 : (atual > 0 ? Infinity : 0); // Avoid division by zero, show Infinity if growing from 0
                }).map(val => isFinite(val) ? val : 100); // Replace Infinity with 100% or another indicator if preferred
                
                // *** LÓGICA DE COR PARA CRESCIMENTO ***
                const corPositiva = '#10B981'; // Verde (igual expedição)
                const corNegativa = '#EF4444'; // Vermelho (cor de perigo)
                // (crescimentoExpColors is no longer needed here, will be calculated in datalabels options)


                // *** MUDANÇA AQUI: Total de horas PREVISTAS ***
                const horasPrevistasPickingData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasPickingMin || 0) / 60);
                const horasPrevistasExpedicaoData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasExpedicaoMin || 0) / 60);
                const horasPrevistasOpEmpData = sortedMonths.map(k => (monthlyAgg[k].horasPrevistasOpEmpMin || 0) / 60); // NOVO
                
                // *** NOVO: Total de horas NORMAIS (COM DESCONTO DE DOWNTIME) ***
                const horasNormaisPickingData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisPickingMin || 0) / 60);
                const horasNormaisExpedicaoData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisExpedicaoMin || 0) / 60);
                const horasNormaisOpEmpData = sortedMonths.map(k => (monthlyAgg[k].horasNormaisOpEmpMin || 0) / 60);
                

                // --- Render Charts ---

                // *** ATUALIZAR TÍTULOS DINÂMICOS ***
                let movTitle = 'Movimentações Mensais';
                let mediaMovTitle = 'Média Diária Movimentação';
                // *** TÍTULO ATUALIZADO (Req 1) ***
                let horasTitle = 'Horas Previstas vs. Normais Trabalhadas (Total Horas/Mês)'; 

                const corTurno1 = '#3B82F6'; // Blue
                const corTurno2 = '#F59E0B'; // Orange
                const corTodos = '#6366F1'; // Indigo

                let movDatasets = [];
                let mediaMovDatasets = [];

                // Sempre adiciona o 1° Turno
                movDatasets.push({ label: '1° Turno', data: movData_T1, backgroundColor: corTurno1, borderColor: corTurno1, borderWidth: 1 });
                mediaMovDatasets.push({ label: '1° Turno', data: mediaMovDiaData_T1, borderColor: corTurno1, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTurno1, pointRadius: 3 });

                if (selectedTurno === '2° TURNO') {
                    movDatasets.push({ label: '2° Turno', data: movData_T2, backgroundColor: corTurno2, borderColor: corTurno2, borderWidth: 1 });
                    mediaMovDatasets.push({ label: '2° Turno', data: mediaMovDiaData_T2, borderColor: corTurno2, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTurno2, pointRadius: 3 });
                    movTitle += ' (1°T vs 2°T)';
                    mediaMovTitle += ' (1°T vs 2°T)';
                } else { // 'todos'
                    movDatasets.push({ label: 'Total (1°+2°T)', data: movData_Todos, backgroundColor: corTodos, borderColor: corTodos, borderWidth: 1 });
                    mediaMovDatasets.push({ label: 'Total (1°+2°T)', data: mediaMovDiaData_Todos, borderColor: corTodos, backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: corTodos, pointRadius: 3 });
                    movTitle += ' (1°T vs Total)';
                    mediaMovTitle += ' (1°T vs Total)';
                }


                 // Define the grid structure for the charts
                 // Using space-y-8 on the container now, each chart group is a div
                 // *** NOVO GRÁFICO (Req 2) ADICIONADO ***
                 operacaoElements.chartsContainer.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        ${createChartContainer('expMensal', 'Expedição Mensal (Itens) e % Crescimento')}
                        ${createChartContainer('movMensais', movTitle)} <!-- Título Dinâmico -->
                    </div>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        ${createChartContainer('mediaExpDia', 'Média Diária Expedição (Itens/Dia Útil)')}
                        ${createChartContainer('mediaMovDia', mediaMovTitle)} <!-- Título Dinâmico -->
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                         ${createChartContainer('horasPrevistas', horasTitle)} <!-- ID e Título Atualizados -->
                         ${createChartContainer('downtimePorMotivo', 'Downtime por Motivo (vs. Total 202:24)')} <!-- NOVO GRÁFICO -->
                    </div>
                `;


                // *** OPÇÕES DE LABELS PARA O GRÁFICO DE EXPEDIÇÃO ***
                const datalabelsExpMensal = {
                    plugins: {
                        datalabels: {
                            display: true, // Habilita os labels para este gráfico
                            anchor: (context) => context.dataset.data[context.dataIndex] >= 0 ? 'end' : 'start', // Posição na barra (fim p/ +, início p/ -)
                            align: (context) => context.dataset.data[context.dataIndex] >= 0 ? 'top' : 'bottom', // Posição relativa (acima p/ +, abaixo p/ -)
                            color: (context) => { // Cor dinâmica
                                const index = context.dataIndex;
                                if (index === 0) return '#D1D5DB'; // Cor neutra (cinza claro) para o primeiro
                                const crescimentoValor = crescimentoExpData[index];
                                return crescimentoValor >= 0 ? corPositiva : corNegativa; // Verde ou Vermelho
                            },
                            font: {
                                weight: 'bold',
                                size: 12 // Aumentado de 10 para 12
                            },
                            formatter: (value, context) => {
                                const index = context.dataIndex;
                                const crescimentoValor = crescimentoExpData[index];
                                if (index === 0) {
                                    return ''; // Não mostra % no primeiro mês
                                }
                                if (crescimentoValor === 0) return '0%'; // Mostra 0%
                                // Evita exibir "Infinity%" se o mês anterior foi 0
                                if (!isFinite(crescimentoValor)) return 'N/A'; 
                                return (crescimentoValor > 0 ? '+' : '') + crescimentoValor.toFixed(1) + '%'; // Mostra +20.5% ou -10.0%
                            },
                            offset: 8, // Aumentado de -5 para 8 (distância da barra)
                            padding: 0
                        }
                    }
                };

                // Render the charts in the new order with ORIGINAL colors
                renderChart('expMensal', 'bar', labels, [{ label: 'Itens Expedidos', data: expData, backgroundColor: '#10B981', borderColor: '#059669', borderWidth: 1 }], datalabelsExpMensal); // Green + LABELS
                renderChart('movMensais', 'bar', labels, movDatasets); // Passa os datasets dinâmicos
                renderChart('mediaExpDia', 'line', labels, [{ label: 'Expedição (Itens/Dia)', data: mediaExpDiaData, borderColor: '#10B981', backgroundColor: 'transparent', fill: false, tension: 0.1, pointBackgroundColor: '#10B981', pointRadius: 3 }]); // Green line
                renderChart('mediaMovDia', 'line', labels, mediaMovDatasets); // Passa os datasets dinâmicos
                
                // *** GRÁFICO REMOVIDO ***
                // renderChart('crescimentoExp', 'bar', labels, [{...}]);
                
                // GRÁFICO REMOVIDO: renderChart('mediaAbs', ...)
                 
                 // *** GRÁFICO ATUALIZADO (Req 1) ***
                 
                // Cores com opacidade
                const corPrevPicking = '#14B8A680'; // Teal 50%
                const corPrevExpedicao = '#F9731680'; // Orange 50%
                const corPrevOpEmp = '#E11D4880'; // Rose 50%
                // Cores Sólidas
                const corNormPicking = '#14B8A6'; // Teal
                const corNormExpedicao = '#F97316'; // Orange
                const corNormOpEmp = '#E11D48'; // Rose
                
                // Opções de sobreposição (Req 1)
                const optionsHoras = {
                    scales: {
                        x: {
                            stacked: true, // Empilha no eixo X (necessário para sobrepor)
                        },
                        y: {
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        // Tooltip customizado (Req 1.1)
                        tooltip: {
                            mode: 'index', // Mostra todos os itens no mesmo índice (mês)
                            intersect: false, // Mostra mesmo sem tocar exatamente na barra
                            
                            // Callbacks para mostrar Apenas o Par (Req 1.2)
                            filter: function (tooltipItem) {
                                // Filtra para mostrar apenas o setor que o mouse está em cima
                                const currentStack = tooltipItem.dataset.stack;
                                return tooltipItem.dataset.stack === currentStack;
                            },
                            
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2) + ' horas';
                                    }
                                    return label;
                                },
                                
                                // (Req 1.2)
                                afterBody: function(tooltipItems) {
                                    // Se já temos os 2 (Previsto e Normal) no corpo, não faz nada
                                    if (tooltipItems.length >= 2) {
                                        return; 
                                    }
                                    
                                    // Se só temos 1, busca o par
                                    if (tooltipItems.length === 1) {
                                        const currentItem = tooltipItems[0];
                                        const chart = currentItem.chart;
                                        const dataIndex = currentItem.dataIndex;
                                        const currentStack = currentItem.dataset.stack;
                                        const currentLabel = currentItem.dataset.label;

                                        // Encontra o dataset "par"
                                        const parDataset = chart.data.datasets.find(ds => 
                                            ds.stack === currentStack && ds.label !== currentLabel
                                        );

                                        if (parDataset) {
                                            const parValue = parDataset.data[dataIndex];
                                            const parLabel = parDataset.label;
                                            return `  ${parLabel}: ${parValue.toFixed(2)} horas`; // Adiciona linha extra
                                        }
                                    }
                                }
                            }
                        }
                    }
                };

                 
                 renderChart('horasPrevistas', 'bar', labels, [
                    // Previstas (Fundo)
                    { label: 'Previstas - Picking', data: horasPrevistasPickingData, backgroundColor: corPrevPicking, stack: 'Picking', barPercentage: 0.8 },
                    { label: 'Previstas - Expedição', data: horasPrevistasExpedicaoData, backgroundColor: corPrevExpedicao, stack: 'Expedição', barPercentage: 0.8 },
                    { label: 'Previstas - Op. Empilhadeira 1°T', data: horasPrevistasOpEmpData, backgroundColor: corPrevOpEmp, stack: 'OpEmp', barPercentage: 0.8 },
                    
                    // Normais (Frente) - Desenhadas por cima
                    { label: 'Normais - Picking', data: horasNormaisPickingData, backgroundColor: corNormPicking, stack: 'Picking', barPercentage: 0.8 },
                    { label: 'Normais - Expedição', data: horasNormaisExpedicaoData, backgroundColor: corNormExpedicao, stack: 'Expedição', barPercentage: 0.8 },
                    { label: 'Normais - Op. Empilhadeira 1°T', data: horasNormaisOpEmpData, backgroundColor: corNormOpEmp, stack: 'OpEmp', barPercentage: 0.8 }
                ], optionsHoras);


                // --- NOVO GRÁFICO: Downtime por Motivo (Req 2) ---
                
                // 1. Preparar dados
                const downtimeLabels = Object.keys(downtimePorMotivoMin);
                const downtimeDataHoras = downtimeLabels.map(motivo => downtimePorMotivoMin[motivo] / 60);
                
                // Total fixo em minutos (202:24)
                const totalHorasFixoMin = (202 * 60) + 24; // 12144 minutos
                
                // 2. Opções do Gráfico (com datalabels)
                const optionsDowntime = {
                    plugins: {
                        datalabels: {
                            display: true,
                            anchor: 'end',
                            align: 'top',
                            color: '#FFFFFF', // Cor do label (branco)
                            font: {
                                weight: 'bold',
                                size: 10
                            },
                            formatter: (value, context) => {
                                // Value é o total de horas (ex: 10.5)
                                // Calcular percentual
                                const percentual = (value * 60 / totalHorasFixoMin) * 100;
                                return `${value.toFixed(2)}h\n(${percentual.toFixed(1)}%)`; // Ex: "10.50h (5.2%)"
                            },
                            offset: 4,
                            textAlign: 'center'
                        },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.parsed.y;
                                    const percentual = (value * 60 / totalHorasFixoMin) * 100;
                                    label += `${value.toFixed(2)} horas (${percentual.toFixed(1)}%)`;
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Horas Totais'
                            }
                        }
                    }
                };

                // 3. Renderizar Gráfico
                renderChart('downtimePorMotivo', 'bar', downtimeLabels, [
                    { 
                        label: 'Horas de Downtime', 
                        data: downtimeDataHoras, 
                        backgroundColor: '#6366F1', // Indigo
                        borderColor: '#4338CA', 
                        borderWidth: 1 
                    }
                ], optionsDowntime);

            }

            function createChartContainer(id, title) {
                return `
                    <div class="bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-md"> <!-- Original card style -->
                        <h3 class="text-lg font-semibold mb-2 text-gray-200">${title}</h3>
                        <div class="chart-container"><canvas id="${id}"></canvas></div>
                    </div>
                `;
            }

            function renderChart(canvasId, type, labels, datasets, customOptions = {}) {
                if (charts[canvasId]) {
                    charts[canvasId].destroy(); // Destroy previous chart instance
                }
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) {
                    console.error(`Canvas element with id "${canvasId}" not found.`);
                    return;
                }
                
                // As cores padrão (Chart.defaults.color e .borderColor) já foram definidas no topo do script.

                // Objeto de opções base com cores de texto corrigidas
                const options = {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(107, 114, 128, 0.3)' // Cor da grade Y (var(--chart-grid-color))
                            },
                            ticks: {
                                 color: '#D1D5DB' // Cor do texto/label Y (var(--chart-label-color))
                            }
                        },
                        x: {
                            grid: {
                                display: false // Hide X-axis grid lines
                            },
                            ticks: {
                                color: '#D1D5DB' // Cor do texto/label X (var(--chart-label-color))
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#D1D5DB' // Cor da legenda (var(--text-color))
                            }
                        },
                        tooltip: { // Estilo original do tooltip
                            backgroundColor: 'rgba(0,0,0,0.7)',
                            titleColor: '#FFFFFF',
                            bodyColor: '#D1D5DB',
                            borderColor: 'rgba(255,255,255,0.1)',
                            borderWidth: 1
                        },
                        // Adiciona plugins customizados (como o datalabels)
                        ...customOptions.plugins 
                    }
                };

                // Mescla escalas customizadas (se houver)
                if (customOptions.scales) {
                    // Simples merge, pode ser melhorado se precisarmos de deep merge
                    if(options.scales.y && customOptions.scales.y) options.scales.y = { ...options.scales.y, ...customOptions.scales.y };
                    if(options.scales.x && customOptions.scales.x) options.scales.x = { ...options.scales.x, ...customOptions.scales.x };
                }
                 // Mescla opções de tooltip (necessário para o gráfico de horas)
                if (customOptions.plugins && customOptions.plugins.tooltip) {
                     // Deep merge simples para tooltip
                    options.plugins.tooltip = { ...options.plugins.tooltip, ...customOptions.plugins.tooltip };
                }
                
                // Determina quais plugins registrar para este gráfico específico
                const pluginsToRegister = [];
                if (customOptions.plugins && customOptions.plugins.datalabels && window.ChartDataLabels) {
                    pluginsToRegister.push(ChartDataLabels);
                }

                charts[canvasId] = new Chart(ctx, {
                    type: type,
                    data: { labels, datasets },
                    options: options, // Usa o objeto de opções mesclado
                    plugins: pluginsToRegister // Registra plugins apenas para este gráfico
                });
            }


            async function getFirestoreCollection(collectionPath) {
                 if (!isFirebaseInitialized || !collectionPath) {
                     console.warn("Firebase not ready or collection path invalid for getFirestoreCollection");
                    return [];
                }
                try {
                    const q = query(collection(db, collectionPath));
                    const querySnapshot = await getDocs(q);
                    const data = [];
                    querySnapshot.forEach(doc => data.push({id: doc.id, ...doc.data()}));
                    // console.log(`Fetched ${data.length} documents from ${collectionPath}`); // Optional: Log success
                    return data;
                } catch (error) {
                    console.error(`Error fetching collection ${collectionPath}:`, error);
                    showFeedback(`Erro ao buscar dados: ${collectionPath.split('/').pop()}. Verifique as regras de segurança.`, "error", 5000);
                    return []; // Return empty array on error
                }
            }


            // --- Expedição Functions ---
            async function handleExpedicaoFile(file) {
                if (!file) return;
                showFileInfo(expedicaoElements, file);
                expedicaoElements.loader.classList.remove('hidden');

                try {
                    const data = await parseExcelOrCsv(file);
                    expedicaoData = processExpedicaoData(data); // Store processed data locally
                    expedicaoElements.loader.classList.add('hidden');
                    showFeedback(`Arquivo de expedição carregado com ${expedicaoData.length} registros válidos.`, "success");
                    if (movimentacoesData.length > 0) {
                        calcularIndicadoresOperacao(); // Recalculate if both datasets are present
                    }
                } catch (error) {
                    console.error("Erro ao processar arquivo de expedição:", error);
                     showFeedback("Houve um erro ao ler o arquivo de expedição. Verifique o formato.", "error");
                    expedicaoElements.loader.classList.add('hidden');
                     // Clear data if processing failed
                     expedicaoData = [];
                     if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                        operacaoElements.chartsContainer.classList.add('hidden');
                        operacaoElements.placeholder.classList.remove('hidden');
                    }
                }
            }

            function processExpedicaoData(data) {
                 // REVERTIDO: Processa Data Envio(K) e Quantidade(Q)
                return data.map(row => {
                    const dataEnvio = excelDateToJSDate(row['Data Envio'] || row['Data envio']); // Coluna K
                    const quantidade = parseFloat(row['Quantidade']); // Coluna Q

                    return {
                        ...row, // Manter dados originais
                        dataEnvio: dataEnvio, // Objeto Date ou null
                        quantidade: !isNaN(quantidade) ? quantidade : 0, // Número
                        // mes e ano não são mais usados para o filtro principal
                    };
                })
                // Filtro REVERTIDO: Requer Data Envio (K) e Quantidade (Q) válidos
                .filter(row => row.dataEnvio instanceof Date && !isNaN(row.dataEnvio) && !isNaN(row.quantidade));
            }


            // --- Absenteísmo Functions ---
            async function handleAbsenteismoFile(file) {
                if (!file) return;
                showFileInfo(absenteismoElements, file);
                absenteismoElements.loader.classList.remove('hidden');
                absenteismoElements.feedback.innerHTML = ''; // Clear previous specific feedback

                try {
                    const { jsonData, reportDate } = await processAbsenteismoFile(file);

                    if(!reportDate) {
                        throw new Error("Não foi possível encontrar a data do relatório no arquivo. Verifique se a data está na 4ª linha (célula C4 ou A4).");
                    }

                    if (!jsonData || jsonData.length === 0) {
                        throw new Error("Nenhum dado de colaborador válido foi encontrado no arquivo. Verifique o formato do arquivo.");
                    }

                    absenteismoData = jsonData; // Store parsed data temporarily
                    absenteismoFileDate = reportDate; // Store parsed date (should be UTC)

                     // Display date in pt-BR format for the user
                    absenteismoElements.datePreview.textContent = reportDate.toLocaleDateString('pt-BR', { timeZone: 'UTC' });
                    absenteismoElements.previewContainer.classList.remove('hidden');
                     absenteismoElements.saveBtn.disabled = false; // Enable save button


                } catch (error) {
                    console.error("Erro ao processar arquivo de absenteísmo:", error);
                    absenteismoElements.feedback.innerHTML = `<p class="text-red-400 text-sm">${error.message}</p>`; // Show specific error
                    absenteismoElements.previewContainer.classList.add('hidden'); // Hide save button on error
                    absenteismoData = []; // Clear data on error
                    absenteismoFileDate = null;
                } finally {
                    absenteismoElements.loader.classList.add('hidden');
                }
            }

            function processAbsenteismoFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];

                            let reportDate = null;
                             // Try C4 first, then A4 for the date string
                            const cellC4 = worksheet['C4'];
                            const cellA4 = worksheet['A4'];

                            let dateLine = '';
                            if (cellC4 && (cellC4.w || cellC4.v)) {
                                dateLine = cellC4.w || String(cellC4.v); // Ensure string conversion
                            } else if (cellA4 && (cellA4.w || cellA4.v)) { // Corrigido: cella4 -> cellA4
                                dateLine = cellA4.w || String(cellA4.v); // Ensure string conversion
                            }

                            if (dateLine) {
                                // Extract the *first* date found in the format dd/mm/yyyy
                                const dateMatch = dateLine.match(/(\d{2}\/\d{2}\/\d{4})/);
                                if (dateMatch && dateMatch[1]) {
                                    const [day, month, year] = dateMatch[1].split('/');
                                    // Create date in UTC to avoid timezone shifts
                                    reportDate = new Date(Date.UTC(year, month - 1, day));
                                    // Validate the created date
                                    if (isNaN(reportDate.getTime())) {
                                        reportDate = null; // Invalidate if date is wrong
                                        console.warn("Invalid date parsed from file:", dateMatch[1]);
                                    }
                                }
                            }

                             // Start reading data from row 5 (index 4)
                            const jsonDataRaw = XLSX.utils.sheet_to_json(worksheet, { range: 4 });

                            const jsonData = jsonDataRaw.filter(row => row && row['Colaborador'] && String(row['Colaborador']).trim()) // Ensure 'Colaborador' exists and is not empty
                                .map(row => ({
                                    colaborador: String(row['Colaborador']).trim(), // Ensure string and trim
                                    // Use empty string as default for potentially missing fields
                                    cargo: String(row['Cargo'] || '').trim(),
                                    locaisDeTrabalho: String(row['Locais de Trabalho'] || '').trim(),
                                    horasPrevistas: String(row['Horas Previstas'] || '00:00').trim(),
                                    horasNormaisTrabalhadas: String(row['Horas Normais Trabalhadas'] || '00:00').trim(),
                                    horasExtras: String(row['Horas Extras'] || '00:00').trim(),
                                    horasTotaisTrabalhadas: String(row['Horas Totais Trabalhadas'] || '00:00').trim()
                                    // Add other relevant fields if needed
                                }));

                            resolve({ jsonData, reportDate });

                        } catch (err) {
                            console.error("Error parsing absenteismo file:", err);
                            reject(new Error("Não foi possível ler o arquivo Excel. Verifique se não está corrompido ou protegido."));
                        }
                    };
                    reader.onerror = (err) => {
                         console.error("FileReader error:", err);
                         reject(new Error("Erro ao ler o arquivo selecionado."));
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            async function saveAbsenteismoToFirestore() {
                 // Use data stored in global state
                if (!isFirebaseInitialized || !absenteismoData || absenteismoData.length === 0 || !absenteismoFileDate) {
                     showFeedback("Não há dados de absenteísmo válidos para salvar ou o Firebase não está pronto.", "warning");
                    return;
                }

                const collectionPath = getFirestorePath('absenteismo');
                if (!collectionPath) {
                    showFeedback("Erro: Não foi possível obter o caminho do banco de dados para absenteísmo.", "error");
                    return;
                }

                absenteismoElements.loader.classList.remove('hidden');
                absenteismoElements.saveBtn.disabled = true;
                absenteismoElements.feedback.innerHTML = ''; // Clear specific feedback

                try {
                    const batch = writeBatch(db);
                    // Format date as YYYY-MM-DD from the UTC date object
                    const dateString = absenteismoFileDate.toISOString().split('T')[0];
                    const displayDate = absenteismoFileDate.toLocaleDateString('pt-BR', { timeZone: 'UTC' }); // For user feedback

                    // --- Check for existing records for this date ---
                    const q = query(collection(db, collectionPath), where("data", "==", dateString));
                    const querySnapshot = await getDocs(q);

                    let overwriteConfirmed = false; // Flag to track confirmation

                    if (!querySnapshot.empty) {
                        // **Temporary Confirmation Replacement:** Since confirm() is blocked,
                        // we'll use the feedback area and require a second click.
                        // Ideally, replace this with a proper modal confirmation dialog.

                        // Check if this is the second click (confirmation)
                        if (absenteismoElements.saveBtn.dataset.confirming === 'true') {
                            overwriteConfirmed = true;
                            // Delete existing documents before adding new ones
                            querySnapshot.forEach(doc => batch.delete(doc.ref));
                            console.log(`Overwriting ${querySnapshot.size} existing records for ${dateString}`);
                            // Reset the button state
                            delete absenteismoElements.saveBtn.dataset.confirming;
                            absenteismoElements.saveBtn.textContent = 'Salvar Histórico';
                        } else {
                            // First click: Show warning and change button state
                            showFeedback(`Já existem dados para ${displayDate}. Clique em 'Confirmar Sobrescrita' para substituí-los.`, "warning", 5000);
                            absenteismoElements.saveBtn.textContent = 'Confirmar Sobrescrita';
                            absenteismoElements.saveBtn.dataset.confirming = 'true'; // Mark as confirming
                            absenteismoElements.loader.classList.add('hidden');
                            absenteismoElements.saveBtn.disabled = false;
                            return; // Stop execution, wait for confirmation click
                        }
                    }

                    // Proceed to save (either first time or after overwrite confirmation)
                    absenteismoData.forEach(record => {
                        // Generate a unique ID based on date and collaborator name (sanitized)
                         const recordId = `${dateString}_${record.colaborador.replace(/[^a-zA-Z0-9\-_]/g, '-')}`; // Allow underscore and hyphen
                        const docRef = doc(db, collectionPath, recordId);
                        // Save the record along with the date string
                        batch.set(docRef, { ...record, data: dateString });
                    });

                    await batch.commit();

                    showFeedback(`Histórico de absenteísmo para ${displayDate} ${overwriteConfirmed ? 'sobrescrito' : 'salvo'} com sucesso!`, "success");
                    absenteismoElements.previewContainer.classList.add('hidden'); // Hide preview after saving
                    loadAbsenteismoHistory(dateString); // Refresh the table to show the newly saved data
                    
                    // Recalcular indicadores se os dados de absenteísmo (necessários para downtime) mudarem
                    if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                        calcularIndicadoresOperacao();
                    }

                    // Reset button state if it was confirming
                    if (absenteismoElements.saveBtn.dataset.confirming) {
                         delete absenteismoElements.saveBtn.dataset.confirming;
                         absenteismoElements.saveBtn.textContent = 'Salvar Histórico';
                    }

                } catch (error) {
                    console.error("Firestore save error: ", error);
                     if (error.code === 'failed-precondition' || (error.message && error.message.includes('offline'))) {
                         showFeedback("Sem conexão. Seus dados serão salvos quando a conexão for restaurada.", "warning");
                     } else {
                         showFeedback("Erro ao salvar o histórico no Firestore.", "error");
                     }
                      // Reset button state on error
                    if (absenteismoElements.saveBtn.dataset.confirming) {
                        delete absenteismoElements.saveBtn.dataset.confirming;
                        absenteismoElements.saveBtn.textContent = 'Salvar Histórico';
                    }
                } finally {
                    absenteismoElements.loader.classList.add('hidden');
                    absenteismoElements.saveBtn.disabled = false;
                }
            }


            async function loadAbsenteismoHistory(filterDate = null) {
                 if (!isFirebaseInitialized) {
                     console.warn("Firebase not ready for loadAbsenteismoHistory");
                    return;
                }
                 const collectionPath = getFirestorePath('absenteismo');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const selectedDate = filterDate || absenteismoElements.dateFilter.value;

                if (!selectedDate) {
                     absenteismoElements.tableContainer.innerHTML = '';
                     absenteismoElements.placeholder.classList.remove('hidden');
                     absenteismoElements.placeholder.querySelector('p').textContent = 'Selecione uma data para visualizar o histórico.';
                    return;
                }

                absenteismoElements.placeholder.classList.add('hidden');
                absenteismoElements.tableContainer.innerHTML = '<p class="text-center text-gray-400">Carregando histórico...</p>';

                try {
                    // Query Firestore for records matching the selected date
                    const q = query(collection(db, collectionPath), where("data", "==", selectedDate));
                    const querySnapshot = await getDocs(q);

                    if (querySnapshot.empty) {
                         // Display date in pt-BR format, ensuring UTC interpretation
                        const displayDate = new Date(selectedDate + 'T00:00:00Z').toLocaleDateString('pt-BR', { timeZone: 'UTC' });
                         absenteismoElements.tableContainer.innerHTML = `<p class="text-center text-gray-400 mt-4">Nenhum registro para ${displayDate}.</p>`;
                        return;
                    }

                    let historyData = [];
                    querySnapshot.forEach((doc) => historyData.push({ id: doc.id, ...doc.data() })); // Include ID if needed
                    renderAbsenteismoTable(historyData); // Render the fetched data

                } catch (error) {
                    console.error("Error loading history: ", error);
                     showFeedback("Erro ao carregar o histórico de absenteísmo.", "error");
                    absenteismoElements.tableContainer.innerHTML = `<p class="text-center text-red-400 mt-4">Erro ao carregar o histórico.</p>`;
                }
            }

            function renderAbsenteismoTable(data) {
                // Sort data alphabetically by collaborator name
                 data.sort((a, b) => (a.colaborador || '').localeCompare(b.colaborador || ''));

                const tableHTML = `
                    <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                        <table class="w-full text-sm text-left text-gray-400">
                            <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Colaborador</th>
                                    <th scope="col" class="px-6 py-3">Cargo</th>
                                    <th scope="col" class="px-6 py-3">Locais de Trabalho</th>
                                    <th scope="col" class="px-6 py-3">Horas Previstas</th>
                                    <th scope="col" class="px-6 py-3">Horas Normais Trabalhadas</th>
                                    <th scope="col" class="px-6 py-3">Horas Extras</th>
                                    <th scope="col" class="px-6 py-3">Horas Totais Trabalhadas</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${data.map(row => `
                                    <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600">
                                        <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${row.colaborador}</th>
                                        <td class="px-6 py-4">${row.cargo || ''}</td>
                                        <td class="px-6 py-4">${row.locaisDeTrabalho || ''}</td>
                                        <td class="px-6 py-4">${row.horasPrevistas || '00:00'}</td>
                                        <td class="px-6 py-4">${row.horasNormaisTrabalhadas || '00:00'}</td>
                                        <td class="px-6 py-4">${row.horasExtras || '00:00'}</td>
                                        <td class="px-6 py-4 font-bold">${row.horasTotaisTrabalhadas || '00:00'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                absenteismoElements.tableContainer.innerHTML = tableHTML;
            }

            // --- Movimentações Empilhadeira Functions ---
            async function handleMovimentacoesFile(file) {
                 if (!file) return;
                showFileInfo(movimentacoesElements, file);
                movimentacoesElements.loader.classList.remove('hidden');

                try {
                    const data = await parseExcelOrCsv(file);
                    movimentacoesData = processMovimentacoesData(data); // Store processed data (already UTC dates)
                    renderMovimentacoesDashboard(); // Render the monthly tables
                    movimentacoesElements.placeholder.classList.add('hidden');
                     showFeedback(`Arquivo de movimentações carregado. ${movimentacoesData.length} linhas processadas inicialmente.`, "success"); // Adjusted message

                     // Recalculate indicators if expedition data is also present
                     if (expedicaoData.length > 0) {
                        calcularIndicadoresOperacao();
                    }
                     // Refresh dashboard if it's the active tab and a date is selected
                    if (tabs.dashboard.btn.classList.contains('active') && dashboardElements.dateFilter.value) {
                         buscarDadosDashboard();
                    }
                } catch (error) {
                    console.error("Erro ao processar arquivo de movimentações:", error);
                     showFeedback("Houve um erro ao ler o arquivo de movimentações.", "error");
                     // Clear data on error
                     movimentacoesData = [];
                     if (movimentacoesElements && movimentacoesElements.dashboardContent && movimentacoesElements.placeholder) {
                        movimentacoesElements.dashboardContent.innerHTML = '';
                        movimentacoesElements.placeholder.classList.remove('hidden');
                    }
                     if (operacaoElements && operacaoElements.chartsContainer && operacaoElements.placeholder) {
                        operacaoElements.chartsContainer.classList.add('hidden');
                        operacaoElements.placeholder.classList.remove('hidden');
                    }
                    if (dashboardElements && dashboardElements.resultsContainer && dashboardElements.placeholder) {
                        dashboardElements.resultsContainer.innerHTML = '';
                        dashboardElements.placeholder.classList.remove('hidden');
                        operatorPerformanceData = {};
                    }
                } finally {
                    movimentacoesElements.loader.classList.add('hidden');
                }
            }

             function processMovimentacoesData(data) {
                 // Process each row but DO NOT filter here
                 return data.map(row => {
                    const jsDate = excelDateToJSDate(row['Data']); // Get UTC Date object (might be null)

                    // Try to get month number directly from 'Mês' column
                    let mesNum = row['Mês'] !== undefined && row['Mês'] !== null && String(row['Mês']).trim() !== '' ? parseInt(String(row['Mês']).trim(), 10) : undefined;
                    if (isNaN(mesNum) || mesNum < 1 || mesNum > 12) {
                        mesNum = undefined; // Invalidate if not 1-12
                    }

                    // Try to get year from 'Data' column, even if date is invalid
                    let yearNum = jsDate?.getUTCFullYear();
                    if (yearNum === undefined) { // If date failed, try other methods
                         if (typeof row['Data'] === 'number' && row['Data'] > 30000) { // Check Excel serial
                             const tempDate = excelDateToJSDate(row['Data']);
                             yearNum = tempDate?.getUTCFullYear();
                         } else if (typeof row['Data'] === 'string') { // Check string for YYYY
                             const match = String(row['Data']).match(/\b(\d{4})\b/);
                             if (match && match[1]) {
                                 const potentialYear = parseInt(match[1], 10);
                                 if (potentialYear > 1900 && potentialYear < 2100) { // Broader sanity check
                                    yearNum = potentialYear;
                                 }
                             }
                         }
                    }

                    // Parse tempo, default to NaN if invalid
                    const tempoParsed = parseFloat(row['Tempo entre movimentos (min)']);

                    return {
                        ano: yearNum, // May be undefined
                        mes: mesNum, // May be undefined
                        data: jsDate, // Keep original Date object or null
                        responsavel: String(row['Responsavel'] || '').trim(),
                        tempo: !isNaN(tempoParsed) ? tempoParsed : NaN, // Ensure tempo is number or NaN
                        tipoMovimentacao: String(row['Tipo movimentação'] || '').trim().toUpperCase(),
                        turno: String(row['Turno'] || '').trim().toUpperCase()
                        // Keep other original fields if needed by spreading row: ...row
                    };
                });
                // REMOVED THE .filter() CALL HERE
            }


            function renderMovimentacoesDashboard() {
                 // Ensure elements exist
                if (!movimentacoesElements || !movimentacoesElements.dashboardContent) {
                    console.error("Movimentacoes dashboard elements not ready.");
                    return;
                }
                const container = movimentacoesElements.dashboardContent;

                if (movimentacoesData.length === 0) {
                     container.innerHTML = ''; // Clear previous content
                     if (movimentacoesElements.placeholder) {
                        movimentacoesElements.placeholder.classList.remove('hidden');
                     }
                    return;
                }
                 // Hide placeholder if we have data
                 if (movimentacoesElements.placeholder) {
                    movimentacoesElements.placeholder.classList.add('hidden');
                 }


                // Group data by month-year (using UTC dates)
                const byMonth = movimentacoesData.reduce((acc, curr) => {
                     // Use 'ano' and 'mes' directly from processed data
                     const year = curr.ano;
                     const month = curr.mes;
                     // Only group if year and month are valid numbers
                     if (typeof year === 'number' && typeof month === 'number' && !isNaN(year) && !isNaN(month)) {
                        const monthYear = `${year}-${String(month).padStart(2, '0')}`;
                        if (!acc[monthYear]) acc[monthYear] = [];
                        acc[monthYear].push(curr);
                    } else {
                         // Optional: Track rows skipped due to invalid year/month
                         // console.warn("Skipping row in byMonth grouping due to invalid year/month:", curr);
                    }
                    return acc;
                }, {});

                const sortedMonths = Object.keys(byMonth).sort().reverse(); // Show most recent first

                let html = '<div class="space-y-8">';
                sortedMonths.forEach(monthKey => {
                    const monthData = byMonth[monthKey];
                    const [year, month] = monthKey.split('-');
                    const monthName = new Date(Date.UTC(year, month - 1)).toLocaleString('pt-BR', { month: 'long', year: 'numeric', timeZone: 'UTC' });

                    const baixarData = monthData.filter(d => d.tipoMovimentacao === 'BAIXAR');
                    const levantarData = monthData.filter(d => d.tipoMovimentacao === 'LEVANTAR');

                    const geralAgg = aggregateByOperator(monthData);
                    const baixarAgg = aggregateByOperator(baixarData);
                    const levantarAgg = aggregateByOperator(levantarData);

                    html += `
                        <div class="bg-gray-800 p-4 rounded-lg border border-gray-700">
                            <h3 class="text-xl font-semibold capitalize text-gray-200 mb-4">${monthName}</h3>

                            <div class="border-b border-gray-600 mb-4">
                                <nav class="-mb-px flex space-x-4 overflow-x-auto pb-px" aria-label="Sub-tabs">
                                    <button data-month="${monthKey}" data-target="geral" class="mov-sub-tab mov-sub-tab-${monthKey} active whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">Geral</button>
                                    <button data-month="${monthKey}" data-target="baixar" class="mov-sub-tab mov-sub-tab-${monthKey} whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300">Baixar</button>
                                    <button data-month="${monthKey}" data-target="levantar" class="mov-sub-tab mov-sub-tab-${monthKey} whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-300">Levantar</button>
                                </nav>
                            </div>

                            <div>
                                <div id="mov-content-${monthKey}-geral" class="mov-sub-content mov-sub-content-${monthKey}">
                                    ${generateOperatorTableHTML(geralAgg, 'META TEMPO DE MOVIMENTAÇÃO')}
                                </div>
                                <div id="mov-content-${monthKey}-baixar" class="mov-sub-content mov-sub-content-${monthKey} hidden">
                                    ${generateOperatorTableHTML(baixarAgg, 'Meta baixar')}
                                </div>
                                <div id="mov-content-${monthKey}-levantar" class="mov-sub-content mov-sub-content-${monthKey} hidden">
                                    ${generateOperatorTableHTML(levantarAgg, 'Meta levantar')}
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                container.innerHTML = html;
            }

            function aggregateByOperator(data) {
                return data.reduce((acc, curr) => {
                    const key = curr.responsavel || 'Desconhecido'; // Handle potential missing names
                    if (!acc[key]) {
                        acc[key] = { count: 0, totalTime: 0 };
                    }
                    acc[key].count++;
                     if (!isNaN(curr.tempo)) { // Only add if tempo is a valid number
                        acc[key].totalTime += curr.tempo;
                     }
                    return acc;
                }, {});
            }

            function generateOperatorTableHTML(operatorData, metaKey) {
                const metaConfig = metasPorAtividade[metaKey] || { meta: 0, unidade: '/ Min' };
                const metaTempo = metaConfig.meta; // Target time in minutes

                if (Object.keys(operatorData).length === 0) {
                    return '<p class="text-center text-gray-400 p-4">Nenhum dado para este filtro.</p>';
                }

                const operatorEntries = Object.entries(operatorData);
                 // Sort by average time (ascending), handle count = 0
                operatorEntries.sort((a, b) => {
                    const avgA = a[1].count > 0 ? a[1].totalTime / a[1].count : Infinity;
                    const avgB = b[1].count > 0 ? b[1].totalTime / b[1].count : Infinity;
                    return avgA - avgB;
                });

                return `
                    <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                        <table class="w-full text-sm text-left text-gray-400">
                            <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Operador</th>
                                    <th scope="col" class="px-6 py-3">Qtd. Movimentada</th>
                                    <th scope="col" class="px-6 py-3">Tempo Médio (min)</th>
                                    <th scope="col" class="px-6 py-3">Meta de Tempo (min)</th>
                                    <th scope="col" class="px-6 py-3">% Atingido</th>
                                </tr>
                            </thead>
                            <tbody>
                            ${operatorEntries.map(([operador, data]) => {
                                 // Handle division by zero if count is 0
                                const tempoMedio = data.count > 0 ? data.totalTime / data.count : 0;
                                // Calculate percentage: (Meta Time / Average Time) * 100
                                const percentual = metaTempo > 0 && tempoMedio > 0 ? (metaTempo / tempoMedio) * 100 : 0;
                                 let corPercentual = 'text-red-400';
                                if (percentual >= 100) { // Met or exceeded time goal (faster or equal)
                                    corPercentual = 'text-green-400';
                                } else if (percentual >= 90) { // Close to goal
                                    corPercentual = 'text-yellow-400';
                                }
                                return `
                                <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600">
                                    <th scope="row" class="px-6 py-4 font-medium text-white whitespace-nowrap">${operador}</th>
                                    <td class="px-6 py-4">${data.count}</td>
                                    <td class="px-6 py-4">${tempoMedio > 0 ? tempoMedio.toFixed(2) : '--'}</td>
                                    <td class="px-6 py-4">${metaTempo > 0 ? metaTempo.toFixed(2) : '--'}</td>
                                    <td class="px-6 py-4 font-bold ${corPercentual}">${metaTempo > 0 && tempoMedio > 0 ? percentual.toFixed(2) + '%' : '--'}</td>
                                </tr>
                                `
                            }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }


            // --- Regras Functions ---
            async function saveRegraDowntime(e) {
                e.preventDefault();
                 if (!isFirebaseInitialized) {
                    showFeedback("Firebase não inicializado. Não é possível salvar.", "error");
                    return;
                }
                 const collectionPath = getFirestorePath('regras_downtime');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const motivo = regrasElements.motivoInput.value.trim();
                const tempo = regrasElements.tempoInput.value; // Should be in HH:MM format

                if (!motivo || !tempo || !/^\d{2}:\d{2}$/.test(tempo)) { // Basic validation for HH:MM
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-orange-400 text-sm">Preencha o motivo e o tempo no formato HH:MM.</p>`;
                    return;
                }

                try {
                    await addDoc(collection(db, collectionPath), { motivo, tempo });
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-green-400 text-sm">Regra salva com sucesso!</p>`;
                    regrasElements.downtimeForm.reset();
                } catch (error) {
                    console.error("Error saving downtime rule:", error);
                    regrasElements.downtimeFeedback.innerHTML = `<p class="text-red-400 text-sm">Erro ao salvar a regra.</p>`;
                }
                setTimeout(() => {
                     if (regrasElements.downtimeFeedback) regrasElements.downtimeFeedback.innerHTML = '';
                 }, 3000);
            }

            function listenForDowntimeUpdates() {
                 if (!isFirebaseInitialized) return;
                 const collectionPath = getFirestorePath('regras_downtime');
                 if (!collectionPath) return;

                if (unsubDowntime) unsubDowntime(); // Unsubscribe from previous listener

                const q = query(collection(db, collectionPath));
                unsubDowntime = onSnapshot(q, (querySnapshot) => {
                    downtimeRules = [];
                    querySnapshot.forEach((doc) => downtimeRules.push({ id: doc.id, ...doc.data() }));
                     downtimeRules.sort((a,b) => (a.motivo || '').localeCompare(b.motivo || '')); // Sort alphabetically
                    renderDowntimeTable(downtimeRules);
                     
                     // *** ADICIONADO: Recalcular indicadores se as regras mudarem ***
                     if (expedicaoData.length > 0 && movimentacoesData.length > 0) {
                        calcularIndicadoresOperacao();
                    }
                     
                     // Refresh downtime modal options if it's currently open
                    if (dashboardElements && !dashboardElements.modal.classList.contains('hidden') && dashboardElements.modalOperatorId.value) {
                       openDowntimeModal(dashboardElements.modalOperatorId.value); // Usa REGRAS, não as lançadas
                    }
                }, (error) => {
                     console.error("Error listening for downtime rule updates:", error);
                     showFeedback("Erro ao carregar regras de downtime.", "error");
                });
            }

            function renderDowntimeTable(regras) {
                 if (!regrasElements || !regrasElements.downtimeListContainer) return;
                const container = regrasElements.downtimeListContainer;
                if (regras.length === 0) {
                    container.innerHTML = `<p class="text-center text-gray-400">Nenhuma regra de downtime cadastrada.</p>`;
                    return;
                }

                container.innerHTML = `
                     <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                         <table class="w-full text-sm text-left text-gray-400">
                             <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Motivo</th>
                                    <th scope="col" class="px-6 py-3">Tempo (HH:MM)</th>
                                    <th scope="col" class="px-6 py-3">Ação</th>
                                </tr>
                             </thead>
                             <tbody>
                                ${regras.map(regra => `
                                    <tr class="bg-gray-800 border-b border-gray-700">
                                        <td class="px-6 py-4">${regra.motivo || 'N/A'}</td>
                                        <td class="px-6 py-4">${regra.tempo || '--:--'}</td>
                                        <td class="px-6 py-4">
                                            <button data-id="${regra.id}" class="delete-downtime-rule-btn text-red-500 hover:text-red-700 text-xs">Remover</button>
                                        </td>
                                    </tr>
                                `).join('')}
                             </tbody>
                         </table>
                     </div>
                `;
            }

            async function deleteRule(e) {
                 if (!isFirebaseInitialized) {
                    showFeedback("Firebase não inicializado.", "error");
                    return;
                 }
                let docId = null;
                let collectionName = null;
                 let actionType = null; // To differentiate between rule deletion and launched downtime deletion

                 // Check if deleting a downtime RULE
                 if (e.target.classList.contains('delete-downtime-rule-btn')) {
                    docId = e.target.dataset.id;
                    collectionName = 'regras_downtime';
                    actionType = 'rule';
                }
                // Check if deleting a meta RULE
                else if (e.target.classList.contains('delete-meta-btn')) {
                    docId = e.target.dataset.id;
                     collectionName = 'regras_meta';
                     actionType = 'rule';
                }
                // Check if removing a LAUNCHED downtime instance
                else if (e.target.classList.contains('remove-downtime-item')) {
                     docId = e.target.dataset.downtimeId; // Use the specific ID for the launched instance
                     collectionName = 'downtimes_lancados';
                     actionType = 'launched';
                     const operatorId = e.target.dataset.operator; // Needed to update local state

                      if (!docId || !operatorId) {
                         console.error("Missing ID or operator for launched downtime deletion");
                         showFeedback("Erro ao tentar remover downtime lançado.", "error");
                        return;
                     }

                     const collectionPath = getFirestorePath(collectionName);
                     if (!collectionPath) return;

                      try {
                        await deleteDoc(doc(db, collectionPath, docId));
                        showFeedback("Downtime lançado removido.", "success");

                         // Remove from local state and update UI
                         if(operatorPerformanceData[operatorId] && operatorPerformanceData[operatorId].downtimes) {
                             // Find the index by ID
                             const indexToRemove = operatorPerformanceData[operatorId].downtimes.findIndex(dt => dt.id === docId);
                             if (indexToRemove > -1) {
                                 operatorPerformanceData[operatorId].downtimes.splice(indexToRemove, 1);
                             } else {
                                 console.warn("Could not find launched downtime in local state to remove:", docId);
                             }
                             // Refresh modal if open, and dashboard table
                             if (!dashboardElements.modal.classList.contains('hidden')) {
                                openDowntimeModal(operatorId);
                             }
                             renderDashboard(); // Recalculate and re-render dashboard
                         } else {
                             console.warn("Operator data not found locally to remove downtime:", operatorId);
                              // Still try to refresh dashboard in case it affects calculations
                              renderDashboard();
                         }

                     } catch (error) {
                        console.error(`Error deleting launched downtime (${docId}):`, error);
                        showFeedback("Erro ao remover o downtime lançado.", "error");
                     }
                    return; // Stop further processing for this specific case
                }


                 // Process deletion for RULES (downtime or meta)
                 if (actionType === 'rule' && docId && collectionName) {
                     const collectionPath = getFirestorePath(collectionName);
                     if (!collectionPath) {
                        showFeedback("Erro: Caminho do banco de dados inválido para regras.", "error");
                        return;
                    }
                    try {
                        await deleteDoc(doc(db, collectionPath, docId));
                         showFeedback("Regra removida com sucesso.", "success");
                         // Firestore listener will automatically update the table for rules
                    } catch (error) {
                        console.error(`Error deleting ${collectionName} rule (${docId}):`, error);
                         showFeedback("Erro ao remover a regra.", "error");
                    }
                }
            }


            async function saveMeta(e) {
                e.preventDefault();
                if (!isFirebaseInitialized) {
                    showFeedback("Firebase não inicializado. Não é possível salvar.", "error");
                    return;
                }
                 const collectionPath = getFirestorePath('regras_meta');
                 if (!collectionPath) {
                    // Feedback already shown by getFirestorePath
                    return;
                }

                const atividade = regrasElements.metaAtividadeInput.value.trim();
                const metaValue = regrasElements.metaValorInput.value; // Get value as string first
                const unidade = regrasElements.metaUnidadeInput.value;

                // Validate input
                if (!atividade) {
                    regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">Por favor, insira o nome da atividade.</p>`;
                    return;
                }
                const meta = Number(metaValue); // Convert to number
                if (metaValue === '' || isNaN(meta) || meta < 0) {
                     regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">Por favor, insira um valor numérico não negativo para a meta.</p>`;
                    return;
                }


                try {
                     // Check if a meta with this activity name already exists (case-sensitive check)
                    const q = query(collection(db, collectionPath), where("atividade", "==", atividade));
                    const querySnapshot = await getDocs(q);

                     if (!querySnapshot.empty) {
                        // Meta already exists. Provide feedback.
                        regrasElements.metaFeedback.innerHTML = `<p class="text-orange-400 text-sm">Já existe uma meta para "${atividade}". Remova a antiga primeiro se quiser criar uma nova ou editar.</p>`;
                        // Optional: Implement update logic here if desired
                        // const existingDoc = querySnapshot.docs[0];
                        // await setDoc(doc(db, collectionPath, existingDoc.id), { atividade, meta, unidade }); // Example update
                    } else {
                         // Add new meta
                        await addDoc(collection(db, collectionPath), { atividade, meta, unidade });
                        regrasElements.metaFeedback.innerHTML = `<p class="text-green-400 text-sm">Meta salva com sucesso!</p>`;
                        regrasElements.metaForm.reset();
                     }
                } catch (error) {
                    console.error("Error saving meta:", error);
                    regrasElements.metaFeedback.innerHTML = `<p class="text-red-400 text-sm">Erro ao salvar a meta.</p>`;
                }
                 // Clear feedback message after a delay
                setTimeout(() => {
                    if (regrasElements.metaFeedback) regrasElements.metaFeedback.innerHTML = '';
                 }, 3000);
            }

            function listenForMetasUpdates() {
                 if (!isFirebaseInitialized) return;
                 const collectionPath = getFirestorePath('regras_meta');
                 if (!collectionPath) return;

                if (unsubMetas) unsubMetas(); // Unsubscribe from previous listener

                const q = query(collection(db, collectionPath));
                unsubMetas = onSnapshot(q, (querySnapshot) => {
                    const metas = [];
                    metasPorAtividade = {}; // Reset and repopulate the map
                    querySnapshot.forEach((doc) => {
                        const data = doc.data();
                        // Basic validation on fetched data
                        if (data.atividade && typeof data.meta === 'number' && data.unidade) {
                            metas.push({ id: doc.id, ...data });
                            metasPorAtividade[data.atividade] = { meta: data.meta, unidade: data.unidade };
                        } else {
                            console.warn("Invalid meta data fetched from Firestore:", doc.id, data);
                        }
                    });
                     metas.sort((a,b) => (a.atividade || '').localeCompare(b.atividade || '')); // Sort alphabetically
                    renderMetasTable(metas);
                    // Refresh related views that depend on metas
                    if (movimentacoesData.length > 0) {
                        renderMovimentacoesDashboard();
                    }
                     if (Object.keys(operatorPerformanceData).length > 0) {
                        renderDashboard();
                    }
                }, (error) => {
                    console.error("Error listening for meta rule updates:", error);
                     showFeedback("Erro ao carregar metas.", "error");
                });
            }

            function renderMetasTable(metas) {
                 if (!regrasElements || !regrasElements.metaListContainer) return;
                const container = regrasElements.metaListContainer;
                if (metas.length === 0) {
                    container.innerHTML = `<p class="text-center text-gray-400">Nenhuma meta cadastrada.</p>`;
                    return;
                }

                container.innerHTML = `
                     <div class="overflow-x-auto relative shadow-md sm:rounded-lg">
                         <table class="w-full text-sm text-left text-gray-400">
                             <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th scope="col" class="px-6 py-3">Atividade</th>
                                    <th scope="col" class="px-6 py-3">Meta</th>
                                    <th scope="col" class="px-6 py-3">Unidade</th>
                                    <th scope="col" class="px-6 py-3">Ação</th>
                                </tr>
                             </thead>
                             <tbody>
                                ${metas.map(meta => `
                                    <tr class="bg-gray-800 border-b border-gray-700">
                                        <td class="px-6 py-4">${meta.atividade || 'N/A'}</td>
                                        <td class="px-6 py-4">${meta.meta}</td>
                                        <td class="px-6 py-4">${meta.unidade || 'N/A'}</td>
                                        <td class="px-6 py-4">
                                            <button data-id="${meta.id}" class="delete-meta-btn text-red-500 hover:text-red-700 text-xs">Remover</button>
                                        </td>
                                    </tr>
                                `).join('')}
                             </tbody>
                         </table>
                     </div>
                `;
            }


            // --- Generic Functions ---
            function parseExcelOrCsv(file) {
                 // Uses SheetJS (xlsx library) loaded globally
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = new Uint8Array(e.target.result);
                             // Attempt to parse dates, but handle potential errors or inconsistencies
                            const workbook = XLSX.read(data, { type: 'array', cellDates: true, dateNF:'dd/mm/yyyy' });
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            // header: 1 ensures the first row is treated as headers
                            const json = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                            if (json.length < 2) { // Need at least header + 1 data row
                                resolve([]); // Return empty if no data
                                return;
                            }

                             // Assume first row is headers
                            const headers = json[0].map(h => String(h || '').trim());
                            const dataRows = json.slice(1);

                            const formattedJson = dataRows.map(rowArray => {
                                let rowObject = {};
                                headers.forEach((header, index) => {
                                     // Ensure index is within bounds of the current rowArray
                                    if(index < rowArray.length){
                                        rowObject[header] = rowArray[index];
                                    } else {
                                        rowObject[header] = undefined; // Or null, or '', depending on desired handling
                                    }
                                });
                                return rowObject;
                            });

                            resolve(formattedJson);
                        } catch (err) {
                            console.error("Error parsing file with SheetJS:", err);
                            reject(new Error("Falha ao processar o arquivo. Verifique o formato."));
                        }
                    };
                    reader.onerror = (err) => {
                         console.error("FileReader error:", err);
                         reject(new Error("Erro ao ler o arquivo selecionado."));
                    };
                    reader.readAsArrayBuffer(file);
                });
            }

            function excelDateToJSDate(serialOrDate) {
                 if (serialOrDate === null || serialOrDate === undefined || serialOrDate === '') return null;

                // 1. Check if it's already a valid JS Date object
                if (serialOrDate instanceof Date && !isNaN(serialOrDate)) {
                    // Create a new Date object representing the same date in UTC
                    return new Date(Date.UTC(serialOrDate.getFullYear(), serialOrDate.getMonth(), serialOrDate.getDate()));
                }

                // 2. Check if it's an Excel serial number (number type)
                if (typeof serialOrDate === 'number' && isFinite(serialOrDate)) {
                     // Check if it's potentially a valid Excel date range (avoids very small/large numbers)
                     if (serialOrDate > 0 && serialOrDate < 2958466) { // Approx year 1900 to 9999
                        const utc_days = Math.floor(serialOrDate - 25569);
                        const utc_value = utc_days * 86400; // Seconds in a day
                        const date_info = new Date(utc_value * 1000); // Milliseconds from epoch

                         // Validate the resulting date parts
                         const year = date_info.getUTCFullYear();
                         const month = date_info.getUTCMonth();
                         const day = date_info.getUTCDate();

                         // Basic sanity check for the parsed date
                         if (year > 1899 && year < 3000) {
                              // Create date in UTC
                            return new Date(Date.UTC(year, month, day));
                         } else {
                              console.warn("Parsed Excel date resulted in an unlikely year:", year, "from serial:", serialOrDate);
                              return null; // Return null if the year seems wrong
                         }
                    } else {
                        // console.warn("Number is outside the expected Excel date serial range:", serialOrDate);
                         return null; // Number likely isn't an Excel date
                     }
                }

                // 3. Check if it's a string and try parsing common formats
                if (typeof serialOrDate === 'string') {
                    const trimmedDate = serialOrDate.trim();
                    let dateObj = null;

                    // Try ISO format (YYYY-MM-DD) or (YYYY/MM/DD) potentially with time
                    if (/^\d{4}[-\/]\d{1,2}[-\/]\d{1,2}/.test(trimmedDate)) {
                         // Attempt to create a date object. If time is present, it might affect the UTC date.
                         // It's safer to reconstruct just the date part in UTC.
                         try {
                             const parts = trimmedDate.split(/[-\/ T]/); // Split by '-', '/', ' ', or 'T'
                             if (parts.length >= 3) {
                                 const year = parseInt(parts[0], 10);
                                 const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed
                                 const day = parseInt(parts[2], 10);
                                 if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                                     dateObj = new Date(Date.UTC(year, month, day));
                                 }
                             }
                         } catch (e) { /* ignore parse error */ }
                    }
                    // Try DD/MM/YYYY or DD-MM-YYYY potentially with time
                    else if (/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/.test(trimmedDate)) {
                        const parts = trimmedDate.match(/^(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/);
                        if (parts) {
                            // parts[1] = day, parts[2] = month, parts[3] = year
                            const year = parseInt(parts[3], 10);
                            const month = parseInt(parts[2], 10) - 1; // Month is 0-indexed
                            const day = parseInt(parts[1], 10);
                            if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                                 dateObj = new Date(Date.UTC(year, month, day));
                            }
                        }
                    }
                    // Add more formats here if needed

                    // Validate the parsed date from string
                    if (dateObj instanceof Date && !isNaN(dateObj)) {
                        return dateObj; // Return the UTC date object
                    }
                }

                // If none of the above worked, log a warning and return null
                 // console.warn("Could not parse date:", serialOrDate, typeof serialOrDate);
                return null;
            }


            function timeStringToMinutes(timeStr) {
                 // *** CORREÇÃO: Permite horas > 23 (ex: 44:00) ***
                if (!timeStr || typeof timeStr !== 'string') return 0;
                const parts = String(timeStr).trim().split(':');
                 if (parts.length >= 2) {
                     const hours = parseInt(parts[0], 10);
                    const minutes = parseInt(parts[1], 10);
                     // Check if both parts are valid numbers
                     // REMOVIDO: Limite de hours < 24
                     if (!isNaN(hours) && !isNaN(minutes) && hours >= 0 && minutes >= 0 && minutes < 60) {
                         return (hours * 60) + minutes;
                     }
                }
                 // Try parsing potential Excel time fractions (less common for HH:MM format, but possible)
                 if (!isNaN(parseFloat(timeStr)) && parseFloat(timeStr) < 1 && parseFloat(timeStr) > 0) {
                     return Math.round(parseFloat(timeStr) * 1440); // 1440 minutes in a day
                 }

                 // console.warn("Could not parse time string to minutes:", timeStr); // Log if parsing fails
                return 0;
            }

            function minutesToHoursAndMinutes(totalMinutes) {
                if (totalMinutes === null || totalMinutes === undefined || isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
                const hours = Math.floor(totalMinutes / 60);
                const minutes = Math.round(totalMinutes % 60);
                 // Handle potential rounding to 60 minutes
                 if (minutes === 60) {
                     return `${String(hours + 1).padStart(2, '0')}:00`;
                 }
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }


            // --- Dashboard Functions ---

            async function buscarDadosDashboard() {
                const selectedDate = dashboardElements.dateFilter.value; // Expects "YYYY-MM-DD"
                if (!selectedDate) {
                     showFeedback("Por favor, selecione uma data.", "warning");
                    return;
                }
                 if (!isFirebaseInitialized) {
                    showFeedback("Firebase não inicializado. Não é possível buscar dados.", "error");
                    return;
                }
                 // Ensure movimentacoesData is loaded
                 if (movimentacoesData.length === 0) {
                    showFeedback("Por favor, importe o arquivo de movimentações de empilhadeira primeiro.", "warning");
                     dashboardElements.placeholder.classList.remove('hidden'); // Show placeholder
                     dashboardElements.resultsContainer.innerHTML = ''; // Clear results/loader
                     dashboardElements.feedback.innerHTML = ''; // Clear 'searching' feedback
                    return;
                 }


                dashboardElements.feedback.innerHTML = `<p class="text-blue-400">Buscando dados...</p>`;
                dashboardElements.placeholder.classList.add('hidden');
                dashboardElements.resultsContainer.innerHTML = '<div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-600 h-12 w-12 mx-auto"></div>'; // Show loader
                operatorPerformanceData = {}; // Reset performance data

                // --- Define Firestore paths ---
                const absenteismoPath = getFirestorePath('absenteismo');
                const downtimesPath = getFirestorePath('downtimes_lancados');
                if (!absenteismoPath || !downtimesPath) {
                    // Feedback handled by getFirestorePath
                    dashboardElements.resultsContainer.innerHTML = ''; // Clear loader
                    return;
                }

                try {
                    // 1. Fetch Absenteísmo data from Firestore for the selected date
                    const qAbs = query(collection(db, absenteismoPath), where("data", "==", selectedDate));
                    const absSnapshot = await getDocs(qAbs);

                    if (absSnapshot.empty) {
                        dashboardElements.feedback.innerHTML = ``; // Clear searching message
                        const displayDate = new Date(selectedDate + 'T00:00:00Z').toLocaleDateString('pt-BR', { timeZone: 'UTC' });
                        showFeedback(`Nenhum registro de absenteísmo encontrado para ${displayDate}.`, "warning");
                        dashboardElements.resultsContainer.innerHTML = ''; // Clear loader
                        dashboardElements.placeholder.classList.remove('hidden'); // Show placeholder again
                         dashboardElements.placeholder.querySelector('h3').textContent = 'Sem dados de Absenteísmo';
                         dashboardElements.placeholder.querySelector('p').textContent = `Não há registros de ponto para ${displayDate}. Importe o arquivo de absenteísmo correspondente.`;
                        return;
                    }

                    absSnapshot.forEach(doc => {
                        const data = doc.data();
                         // Ensure collaborator name is valid before using as key
                         if (data.colaborador && typeof data.colaborador === 'string' && data.colaborador.trim()) {
                            operatorPerformanceData[data.colaborador.trim()] = {
                                id: doc.id,
                                horasTrabalhadas: data.horasTotaisTrabalhadas || '00:00', // Default if missing
                                downtimes: [],
                                totalMovimentos: 0
                            };
                        } else {
                            console.warn("Absenteism record missing or invalid collaborator name:", doc.id, data);
                        }
                    });

                    // 2. Filter local Movimentações data (already processed, UTC dates)
                    const movimentacoesDoDia = movimentacoesData.filter(m => {
                        // Ensure 'data' exists and is a valid Date object before trying to format
                        return m.data instanceof Date && !isNaN(m.data) && m.data.toISOString().split('T')[0] === selectedDate;
                    });


                    // 3. Count relevant movements
                    movimentacoesDoDia.forEach(mov => {
                         const operatorKey = mov.responsavel; // Already trimmed in processing
                         if (operatorKey && operatorPerformanceData[operatorKey]) { // Check if operator exists in performance data
                            if ((mov.tipoMovimentacao === 'BAIXAR' || mov.tipoMovimentacao === 'LEVANTAR') && mov.turno === '1° TURNO') {
                                operatorPerformanceData[operatorKey].totalMovimentos++;
                            }
                        } else if (operatorKey) {
                             // Operator exists in movements but not in absenteism - log warning maybe?
                             // console.warn(`Movement found for operator "${operatorKey}" but no matching absenteism record on ${selectedDate}.`);
                        }
                    });


                    // 4. Fetch *launched* Downtimes from Firestore for the selected date
                    // *** MUDANÇA: AGORA USA AS REGRAS (downtimeRules) em vez de downtimes_lancados ***
                    // Esta seção (4) agora aplica as REGRAS DIÁRIAS ao dia selecionado.
                    
                    // 4.1 Calcular a "taxa diária" de downtime (baseado na lógica da Req 1)
                    let totalDiasUteisPicking = 0;
                    let totalDiasUteisExpedicao = 0;
                    let totalDiasUteisOpEmp = 0;

                    // Re-calcular total de dias úteis (baseado em todos os dados de absenteísmo)
                    const allAbsData = await getFirestoreCollection(absenteismoPath);
                    const diasUteisUnicos = { PICKING: new Set(), EXPEDIÇÃO: new Set(), OP_EMP: new Set() };
                    
                    allAbsData.forEach(item => {
                         const locais = String(item.locaisDeTrabalho || '').toUpperCase();
                         if (locais.includes('PICKING')) diasUteisUnicos.PICKING.add(item.data);
                         if (locais.includes('EXPEDIÇÃO')) diasUteisUnicos.EXPEDIÇÃO.add(item.data);
                         if (locais.includes('OPERADOR DE EMPILHADEIRA 1° TURNO')) diasUteisUnicos.OP_EMP.add(item.data);
                    });
                    
                    // 4.3 Calcular taxa diária (MUDANÇA: Usar 21 dias fixos)
                    const DIAS_UTEIS_FIXOS_PARA_TAXA = 21;
                    
                    const taxaDiariaPicking = (downtimeTotalMinPorSetor.PICKING + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;
                    const taxaDiariaExpedicao = (downtimeTotalMinPorSetor.EXPEDIÇÃO + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;
                    const taxaDiariaOpEmp = (downtimeTotalMinPorSetor.OP_EMP + downtimeTotalMinPorSetor.GERAL) / DIAS_UTEIS_FIXOS_PARA_TAXA;
                    
                    // 4.4 Aplicar o downtime DIÁRIO (taxa) aos operadores do dia selecionado
                    // (Substitui a busca por downtimes_lancados)
                    
                    // Precisamos saber o setor do operador NO DIA ATUAL (selectedDate)
                    // Usar os dados de absenteísmo do dia (absSnapshot)
                    absSnapshot.forEach(doc => {
                         const data = doc.data();
                         const operatorKey = data.colaborador.trim();
                         if (operatorPerformanceData[operatorKey]) {
                             const locais = String(data.locaisDeTrabalho || '').toUpperCase();
                             let downtimeDoDiaMin = 0;
                             
                             if (locais.includes('PICKING')) {
                                 downtimeDoDiaMin = taxaDiariaPicking;
                             } else if (locais.includes('EXPEDIÇÃO')) {
                                 downtimeDoDiaMin = taxaDiariaExpedicao;
                             } else if (locais.includes('OPERADOR DE EMPILHADEIRA 1° TURNO')) {
                                 downtimeDoDiaMin = taxaDiariaOpEmp;
                             }
                             
                             if (downtimeDoDiaMin > 0) {
                                // Adiciona um objeto "virtual" de downtime
                                operatorPerformanceData[operatorKey].downtimes.push({
                                    id: 'REGRA_DIARIA',
                                    motivo: 'Downtime (Regras)',
                                    tempo: minutesToHoursAndMinutes(downtimeDoDiaMin), // Converte de volta para HH:MM
                                    data: selectedDate
                                });
                             }
                         }
                    });
                    
                    // --- FIM DA MUDANÇA (Downtime no Dashboard) ---
                    
                    
                    // 5. Fetch *launched* Downtimes from Firestore for the selected date (Ainda necessário para o modal)
                    const qDown = query(collection(db, downtimesPath), where("data", "==", selectedDate));
                    const downSnapshot = await getDocs(qDown);
                    downSnapshot.forEach(doc => {
                        const data = doc.data();
                         const operatorKey = data.operador; // Assuming operator name is stored directly
                         if (operatorKey && operatorPerformanceData[operatorKey]) { // Check if operator exists
                             // Store the Firestore document ID along with the downtime data
                            // *SÓ ADICIONA SE AINDA NÃO FOR O 'REGRA_DIARIA'*
                            if (!operatorPerformanceData[operatorKey].downtimes.find(d => d.id === 'REGRA_DIARIA')) {
                                operatorPerformanceData[operatorKey].downtimes.push({ id: doc.id, ...data });
                            }
                         } else {
                             console.warn(`Downtime found for operator "${operatorKey}" but no matching absenteism record on ${selectedDate}.`);
                        }
                    });

                    dashboardElements.feedback.innerHTML = ``; // Clear searching message
                    renderDashboard(); // Render the results table

                } catch (error) {
                    console.error("Erro ao buscar dados do dashboard:", error);
                    showFeedback("Ocorreu um erro ao buscar os dados do dashboard.", "error");
                     dashboardElements.resultsContainer.innerHTML = `<p class="text-red-400 text-center">Erro ao carregar dados.</p>`;
                     dashboardElements.placeholder.classList.add('hidden'); // Ensure placeholder is hidden on error
                }
            }


            function renderDashboard() {
                 if (!dashboardElements || !dashboardElements.resultsContainer) return;
                const container = dashboardElements.resultsContainer;

                // Check if operatorPerformanceData is empty
                if (Object.keys(operatorPerformanceData).length === 0) {
                     // This might be hit if absenteism loads but there's an error later, or if absenteism was truly empty
                     container.innerHTML = ''; // Clear potential loader
                     if (dashboardElements.placeholder) {
                        dashboardElements.placeholder.classList.remove('hidden');
                         const displayDate = dashboardElements.dateFilter.value ? new Date(dashboardElements.dateFilter.value + 'T00:00:00Z').toLocaleDateString('pt-BR', { timeZone: 'UTC' }) : 'data selecionada';
                        dashboardElements.placeholder.querySelector('h3').textContent = 'Sem dados de Operador';
                        dashboardElements.placeholder.querySelector('p').textContent = `Não foi possível calcular a performance para ${displayDate}. Verifique os dados de absenteísmo.`;
                     }
                    return;
                }

                // Sort operators alphabetically by name (the key)
                const sortedOperators = Object.entries(operatorPerformanceData).sort((a, b) => a[0].localeCompare(b[0]));

                const tableHTML = `
                    <div class="overflow-x-auto relative shadow-md sm:rounded-lg border border-gray-700">
                        <table class="w-full text-sm text-left text-gray-400">
                            <thead class="text-xs text-gray-300 uppercase bg-gray-700">
                                <tr>
                                    <th class="px-6 py-3 sticky left-0 bg-gray-700 z-10 whitespace-nowrap">Operador</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Horas Trab.</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Downtime Total</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Tempo Produtivo</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Movs (1º T)</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Perf. (Mov/Hr Prod.)</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Meta (Mov/Hr)</th>
                                    <th class="px-6 py-3 whitespace-nowrap">% Meta</th>
                                    <th class="px-6 py-3 whitespace-nowrap">Ações</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sortedOperators.map(([operator, data]) => {
                                    // *** MUDANÇA: AGORA USA AS REGRAS DIÁRIAS (junto com lançados, se houver) ***
                                    const totalDowntimeMinutes = (data.downtimes || []).reduce((sum, dt) => sum + timeStringToMinutes(dt.tempo), 0);
                                    const horasTrabalhadasMinutes = timeStringToMinutes(data.horasTrabalhadas);
                                    const tempoProdutivoMinutes = Math.max(0, horasTrabalhadasMinutes - totalDowntimeMinutes);
                                    const tempoProdutivoHours = tempoProdutivoMinutes / 60;

                                    const performance = tempoProdutivoHours > 0 ? (data.totalMovimentos || 0) / tempoProdutivoHours : 0;

                                    // IMPORTANT: Use consistent meta key
                                    const metaConfig = metasPorAtividade['Movimentação Empilhadeira'] || { meta: 0, unidade: '/ Hr'};
                                    const meta = metaConfig.meta;
                                    const percentual = meta > 0 ? (performance / meta) * 100 : 0;
                                     let corPercentual = 'text-red-400';
                                    if (percentual >= 100) {
                                        corPercentual = 'text-green-400';
                                    } else if (percentual >= 90) {
                                        corPercentual = 'text-yellow-400';
                                    }

                                    return `
                                    <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600">
                                        <th class="px-6 py-4 font-medium text-white whitespace-nowrap sticky left-0 bg-gray-800 z-10">${operator}</th>
                                        <td class="px-6 py-4 whitespace-nowrap">${data.horasTrabalhadas}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">${minutesToHoursAndMinutes(totalDowntimeMinutes)}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">${minutesToHoursAndMinutes(tempoProdutivoMinutes)}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">${data.totalMovimentos || 0}</td>
                                        <td class="px-6 py-4 font-bold whitespace-nowrap">${performance.toFixed(2)}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">${meta > 0 ? meta : '--'}</td>
                                        <td class="px-6 py-4 font-bold ${corPercentual} whitespace-nowrap">${meta > 0 ? percentual.toFixed(2) + '%' : '--'}</td>
                                        <td class="px-6 py-4 whitespace-nowrap">
                                            <button class="lancar-downtime-btn text-blue-400 hover:text-blue-500 text-xs whitespace-nowrap" data-id="${operator}">Lançar/Ver Downtime</button>
                                        </td>
                                    </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
                container.innerHTML = tableHTML;
                 // Hide placeholder after rendering table
                 if(dashboardElements.placeholder) dashboardElements.placeholder.classList.add('hidden');
            }


            function openDowntimeModal(operatorId) {
                // Ensure dashboard elements are ready
                 if (!dashboardElements || !dashboardElements.modal || !dashboardElements.modalOperatorName || !dashboardElements.modalOperatorId || !dashboardElements.modalReasonSelect || !dashboardElements.modalDowntimeList || !dashboardElements.modalForm) {
                    console.error("Downtime modal elements not ready.");
                    showFeedback("Erro ao abrir o modal de downtime.", "error");
                    return;
                }
                const operatorData = operatorPerformanceData[operatorId];
                if (!operatorData) {
                    console.warn("Operator data not found for modal:", operatorId);
                     showFeedback(`Dados do operador ${operatorId} não encontrados.`, "warning");
                    return;
                }


                dashboardElements.modalOperatorName.textContent = operatorId;
                dashboardElements.modalOperatorId.value = operatorId;

                // *** MUDANÇA: Popula o select com REGRAS (downtimeRules) ***
                dashboardElements.modalReasonSelect.innerHTML = downtimeRules.map(rule =>
                    `<option value="${rule.id}">${rule.motivo} (${rule.tempo})</option>`
                ).join('');

                const hasRules = downtimeRules.length > 0;
                 dashboardElements.modalReasonSelect.disabled = !hasRules;
                 dashboardElements.modalForm.querySelector('button[type="submit"]').disabled = !hasRules; // Disable submit if no rules
                 if (!hasRules) {
                    dashboardElements.modalReasonSelect.innerHTML = '<option value="">Cadastre regras na aba "Regras"</option>';
                 }


                // List current launched downtimes (ensure operatorData.downtimes exists)
                // *** MUDANÇA: Filtra para mostrar APENAS os lançados (não os de regra) ***
                const launchedDowntimes = (operatorData.downtimes || []).filter(dt => dt.id !== 'REGRA_DIARIA');
                
                dashboardElements.modalDowntimeList.innerHTML = launchedDowntimes.map((dt, index) => `
                    <div class="flex justify-between items-center bg-gray-700 p-2 rounded text-sm">
                        <span>${dt.motivo} - ${dt.tempo}</span>
                         <button type="button" class="remove-downtime-item text-red-400 hover:text-red-500 text-xs font-bold" data-operator="${operatorId}" data-downtime-id="${dt.id}" title="Remover este lançamento">&times;</button>
                    </div>
                `).join('');

                if(launchedDowntimes.length === 0) {
                     dashboardElements.modalDowntimeList.innerHTML = '<p class="text-xs text-gray-400 text-center">Nenhum downtime (manual) lançado para este operador hoje.</p>';
                 }

                dashboardElements.modal.classList.remove('hidden');
            }

            async function handleDowntimeSubmit(e) {
                e.preventDefault();
                if (!isFirebaseInitialized) {
                    showFeedback("Firebase não inicializado.", "error");
                    return;
                }
                 const collectionPath = getFirestorePath('downtimes_lancados');
                 if (!collectionPath) {
                    // Feedback handled by getFirestorePath
                    return;
                }

                const operatorId = dashboardElements.modalOperatorId.value;
                const reasonId = dashboardElements.modalReasonSelect.value;
                const selectedDate = dashboardElements.dateFilter.value;

                 // *** MUDANÇA: Busca a regra das REGRAS (downtimeRules) ***
                const rule = downtimeRules.find(r => r.id === reasonId);
                 if (!rule || !operatorId || !selectedDate) {
                    showFeedback("Seleção inválida. Verifique o motivo e a data.", "warning");
                    return;
                 }

                const newDowntime = {
                    operador: operatorId,
                    motivo: rule.motivo,
                    tempo: rule.tempo, // HH:MM string
                    data: selectedDate // YYYY-MM-DD string
                };

                 const submitButton = dashboardElements.modalForm.querySelector('button[type="submit"]');
                 submitButton.disabled = true;
                 submitButton.textContent = 'Salvando...';

                try {
                    const docRef = await addDoc(collection(db, collectionPath), newDowntime);
                    const savedData = { id: docRef.id, ...newDowntime };

                     showFeedback("Downtime adicionado com sucesso!", "success");

                    // Update local state safely
                     if (operatorPerformanceData[operatorId]) {
                        if (!operatorPerformanceData[operatorId].downtimes) {
                             operatorPerformanceData[operatorId].downtimes = [];
                        }
                        // Adiciona o downtime MANUALMENTE lançado
                        operatorPerformanceData[operatorId].downtimes.push(savedData);
                         // Refresh modal content (list) and re-render the main dashboard table
                        openDowntimeModal(operatorId);
                        renderDashboard(); // Recalcula o tempo produtivo com o novo downtime
                     } else {
                         console.warn("Operator data missing after saving downtime, dashboard might be stale.");
                         // Might need to refetch dashboard data in this edge case
                     }

                } catch(error) {
                    console.error("Error saving downtime to Firestore:", error);
                    showFeedback("Não foi possível salvar o downtime. Tente novamente.", "error");
                } finally {
                     // Re-enable submit button
                     if (submitButton) { // Check if element still exists
                        submitButton.disabled = !downtimeRules.length > 0; // Disable if no rules exist
                        submitButton.textContent = 'Adicionar Downtime';
                     }
                 }
            }


            // --- Initial Setup ---
             // Select elements safely after DOM is loaded
            tabs = {
                importacao: { btn: document.getElementById('tab-btn-importacao'), content: document.getElementById('tab-content-importacao') },
                dashboard: { btn: document.getElementById('tab-btn-dashboard'), content: document.getElementById('tab-content-dashboard') },
                operacao: { btn: document.getElementById('tab-btn-operacao'), content: document.getElementById('tab-content-operacao') },
                absenteismo: { btn: document.getElementById('tab-btn-absenteismo'), content: document.getElementById('tab-content-absenteismo') },
                movimentacoes: { btn: document.getElementById('tab-btn-movimentacoes'), content: document.getElementById('tab-content-movimentacoes') },
                regras: { btn: document.getElementById('tab-btn-regras'), content: document.getElementById('tab-content-regras') },
            };

            expedicaoElements = {
                dropZone: document.getElementById('expedicao-drop-zone'),
                fileInput: document.getElementById('expedicao-file-input'),
                fileLabel: document.getElementById('expedicao-file-label'),
                fileInfo: document.getElementById('expedicao-file-info'),
                fileInfoP: document.querySelector('#expedicao-file-info p'),
                removeBtn: document.getElementById('expedicao-remove-file-btn'),
                loader: document.getElementById('expedicao-loader'),
            };

            absenteismoElements = {
                dropZone: document.getElementById('absenteismo-drop-zone'),
                fileInput: document.getElementById('absenteismo-file-input'),
                fileLabel: document.getElementById('absenteismo-file-label'),
                fileInfo: document.getElementById('absenteismo-file-info'),
                fileInfoP: document.querySelector('#absenteismo-file-info p'),
                removeBtn: document.getElementById('absenteismo-remove-file-btn'),
                loader: document.getElementById('absenteismo-loader'),
                previewContainer: document.getElementById('absenteismo-preview-container'),
                datePreview: document.getElementById('absenteismo-date-preview'),
                saveBtn: document.getElementById('save-absenteismo-btn'),
                feedback: document.getElementById('absenteismo-feedback'),
                dateFilter: document.getElementById('absenteismo-date-filter'),
                tableContainer: document.getElementById('absenteismo-table-container'),
                placeholder: document.getElementById('absenteismo-placeholder'),
            };

            movimentacoesElements = {
                dropZone: document.getElementById('empilhadeira-drop-zone'),
                fileInput: document.getElementById('empilhadeira-file-input'),
                fileLabel: document.getElementById('empilhadeira-file-label'),
                fileInfo: document.getElementById('empilhadeira-file-info'),
                fileInfoP: document.querySelector('#empilhadeira-file-info p'),
                removeBtn: document.getElementById('empilhadeira-remove-file-btn'),
                loader: document.getElementById('empilhadeira-loader'),
                dashboardContent: document.getElementById('movimentacoes-dashboard-content'),
                placeholder: document.getElementById('movimentacoes-placeholder'),
            };

            operacaoElements = {
                chartsContainer: document.getElementById('operacao-charts-container'),
                placeholder: document.getElementById('operacao-placeholder'),
                turnoFilter: document.getElementById('mov-turno-filter') // ADICIONADO
            };

            dashboardElements = {
                dateFilter: document.getElementById('dashboard-date-filter'),
                fetchBtn: document.getElementById('dashboard-fetch-btn'),
                feedback: document.getElementById('dashboard-feedback'),
                resultsContainer: document.getElementById('dashboard-results-container'),
                placeholder: document.getElementById('dashboard-placeholder'),
                modal: document.getElementById('downtime-modal'),
                modalOperatorName: document.getElementById('modal-operator-name'),
                modalOperatorId: document.getElementById('modal-operator-id'),
                modalReasonSelect: document.getElementById('modal-downtime-reason'),
                modalDowntimeList: document.getElementById('modal-downtime-list'),
                modalCloseBtn: document.getElementById('modal-close-btn'),
                modalForm: document.getElementById('form-lancar-downtime')
            };

            regrasElements = {
                downtimeForm: document.getElementById('form-regra-downtime'),
                motivoInput: document.getElementById('motivo-downtime'),
                tempoInput: document.getElementById('tempo-downtime'),
                downtimeFeedback: document.getElementById('downtime-feedback'),
                downtimeListContainer: document.getElementById('regras-downtime-list-container'),
                metaForm: document.getElementById('form-meta'),
                metaAtividadeInput: document.getElementById('meta-atividade-nome'),
                metaValorInput: document.getElementById('meta-atividade-valor'),
                metaUnidadeInput: document.getElementById('meta-atividade-unidade'),
                metaFeedback: document.getElementById('meta-feedback'),
                metaListContainer: document.getElementById('regras-meta-list-container'),
            };

            // Setup Tab Switching - Ensure elements exist
            Object.keys(tabs).forEach(tabKey => {
                if (tabs[tabKey] && tabs[tabKey].btn) {
                    tabs[tabKey].btn.addEventListener('click', () => switchTab(tabKey));
                } else {
                     console.warn(`Button for tab "${tabKey}" not found.`);
                }
            });

            // Setup File Inputs - Checks are inside setupFileInput

            setupFileInput(expedicaoElements, handleExpedicaoFile);
            setupFileInput(absenteismoElements, handleAbsenteismoFile);
            setupFileInput(movimentacoesElements, handleMovimentacoesFile);


            // Setup Button Clicks & Form Submits - Add checks for element existence
             if(absenteismoElements.saveBtn) absenteismoElements.saveBtn.addEventListener('click', saveAbsenteismoToFirestore);
             if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.addEventListener('change', () => loadAbsenteismoHistory());
             if(regrasElements.downtimeForm) regrasElements.downtimeForm.addEventListener('submit', saveRegraDowntime);
             if(regrasElements.metaForm) regrasElements.metaForm.addEventListener('submit', saveMeta);
             if(regrasElements.downtimeListContainer) regrasElements.downtimeListContainer.addEventListener('click', deleteRule);
             if(regrasElements.metaListContainer) regrasElements.metaListContainer.addEventListener('click', deleteRule);
             if(dashboardElements.fetchBtn) dashboardElements.fetchBtn.addEventListener('click', buscarDadosDashboard);
             if(operacaoElements.turnoFilter) operacaoElements.turnoFilter.addEventListener('change', calcularIndicadoresOperacao); // ADICIONADO

            // Movimentacoes Sub-tab switching - Check container exists
             if(movimentacoesElements.dashboardContent) {
                movimentacoesElements.dashboardContent.addEventListener('click', (e) => {
                    if (e.target.classList.contains('mov-sub-tab')) {
                        const month = e.target.dataset.month;
                        const target = e.target.dataset.target;
                        if (!month || !target) return; // Exit if data attributes are missing

                        document.querySelectorAll(`.mov-sub-tab-${month}`).forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');

                        document.querySelectorAll(`.mov-sub-content-${month}`).forEach(content => content.classList.add('hidden'));
                        const targetContent = document.getElementById(`mov-content-${month}-${target}`);
                         if(targetContent) targetContent.classList.remove('hidden');
                    }
                });
            }

            // Downtime Modal Logic - Check elements exist
             if(dashboardElements.modalCloseBtn) dashboardElements.modalCloseBtn.addEventListener('click', () => dashboardElements.modal.classList.add('hidden'));
             if(dashboardElements.modalForm) dashboardElements.modalForm.addEventListener('submit', handleDowntimeSubmit);
             if(dashboardElements.resultsContainer) {
                dashboardElements.resultsContainer.addEventListener('click', (e) => {
                    if (e.target.classList.contains('lancar-downtime-btn')) {
                        const operatorId = e.target.dataset.id;
                        if (operatorId) openDowntimeModal(operatorId);
                    }
                });
            }
             if(dashboardElements.modalDowntimeList) dashboardElements.modalDowntimeList.addEventListener('click', deleteRule); // For removing launched downtimes


            // Set default dates if elements exist
            try {
                const today = new Date();
                // Format YYYY-MM-DD, considering timezone offset
                const offset = today.getTimezoneOffset();
                const todayLocal = new Date(today.getTime() - (offset*60*1000));
                const todayString = todayLocal.toISOString().split('T')[0];

                if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.value = todayString;
                if(dashboardElements.dateFilter) dashboardElements.dateFilter.value = todayString;
            } catch (e) {
                console.error("Error setting default dates:", e);
                 // Fallback if date setting fails
                 if(absenteismoElements.dateFilter) absenteismoElements.dateFilter.value = '';
                 if(dashboardElements.dateFilter) dashboardElements.dateFilter.value = '';
            }

            // Initialize Firebase connection
            initializeFirebase();
        });

    </script>

</body>

</html>

